<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EF_TMR32 APIs: EF_TMR32.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EF_TMR32 APIs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">EF_TMR32.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>C header file for TMR32 APIs which contains the function prototypes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_e_f___t_m_r32__regs_8h_source.html">EF_TMR32_regs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_e_f___driver___common_8h_source.html">EF_Driver_Common.h</a>&quot;</code><br />
</div>
<p><a href="_e_f___t_m_r32_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a50ad781adeb21f9afdae64c87995dae4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a50ad781adeb21f9afdae64c87995dae4">EF_TMR32_ACTION_NONE</a>&#160;&#160;&#160;((uint32_t)0)</td></tr>
<tr class="memdesc:a50ad781adeb21f9afdae64c87995dae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">No action on match (do nothing)  <br /></td></tr>
<tr class="separator:a50ad781adeb21f9afdae64c87995dae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4dffaa5d4c81e7a4ecae477515e6e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#acb4dffaa5d4c81e7a4ecae477515e6e9">EF_TMR32_ACTION_LOW</a>&#160;&#160;&#160;((uint32_t)1)</td></tr>
<tr class="memdesc:acb4dffaa5d4c81e7a4ecae477515e6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output to LOW when match occurs.  <br /></td></tr>
<tr class="separator:acb4dffaa5d4c81e7a4ecae477515e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ddd00225eb38cfb28c11b42c6842da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#af7ddd00225eb38cfb28c11b42c6842da">EF_TMR32_ACTION_HIGH</a>&#160;&#160;&#160;((uint32_t)2)</td></tr>
<tr class="memdesc:af7ddd00225eb38cfb28c11b42c6842da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output to HIGH when match occurs.  <br /></td></tr>
<tr class="separator:af7ddd00225eb38cfb28c11b42c6842da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3631ac6d9073e4afc9b5fa08752e42"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a9b3631ac6d9073e4afc9b5fa08752e42">EF_TMR32_ACTION_INVERT</a>&#160;&#160;&#160;((uint32_t)3)</td></tr>
<tr class="memdesc:a9b3631ac6d9073e4afc9b5fa08752e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the output when match occurs.  <br /></td></tr>
<tr class="separator:a9b3631ac6d9073e4afc9b5fa08752e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8714853a34747e7e89112230119eb61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#af8714853a34747e7e89112230119eb61">EF_TMR32_ACTION_MAX_VALUE</a>&#160;&#160;&#160;((uint32_t)3)</td></tr>
<tr class="memdesc:af8714853a34747e7e89112230119eb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for the action field.  <br /></td></tr>
<tr class="separator:af8714853a34747e7e89112230119eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab645d9ca5f1c71739678d22149dd0404"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ab645d9ca5f1c71739678d22149dd0404">EF_TMR32_PWMDT_MAX_VALUE</a>&#160;&#160;&#160;((uint32_t)0x000000FF)</td></tr>
<tr class="memdesc:ab645d9ca5f1c71739678d22149dd0404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for the deadtime register.  <br /></td></tr>
<tr class="separator:ab645d9ca5f1c71739678d22149dd0404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86db56e37fbb384e261a39f05208baa3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a86db56e37fbb384e261a39f05208baa3">EF_TMR32_PR_MAX_VALUE</a>&#160;&#160;&#160;((uint32_t)0x0000FFFF)</td></tr>
<tr class="memdesc:a86db56e37fbb384e261a39f05208baa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for the PR register.  <br /></td></tr>
<tr class="separator:a86db56e37fbb384e261a39f05208baa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be953bc2d144836bc6f331f716e980a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a8be953bc2d144836bc6f331f716e980a">EF_TMR32_IM_MAX_VALUE</a>&#160;&#160;&#160;((uint32_t)2)</td></tr>
<tr class="memdesc:a8be953bc2d144836bc6f331f716e980a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for the IM register.  <br /></td></tr>
<tr class="separator:a8be953bc2d144836bc6f331f716e980a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36eec137696cf3d46efd03cf50103b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ad36eec137696cf3d46efd03cf50103b4">EF_TMR32_ICR_MAX_VALUE</a>&#160;&#160;&#160;((uint32_t)2)</td></tr>
<tr class="memdesc:ad36eec137696cf3d46efd03cf50103b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for the ICR register.  <br /></td></tr>
<tr class="separator:ad36eec137696cf3d46efd03cf50103b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a48fee3ba105edc1dcee550925ac90f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a48fee3ba105edc1dcee550925ac90f6d">EF_TMR32_setGclkEnable</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t value)</td></tr>
<tr class="memdesc:a48fee3ba105edc1dcee550925ac90f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the GCLK enable bit in the UART register to a certain value.  <br /></td></tr>
<tr class="separator:a48fee3ba105edc1dcee550925ac90f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bb5b7b456bda2803eb6e0bc907d2b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a03bb5b7b456bda2803eb6e0bc907d2b4">EF_TMR32_enable</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:a03bb5b7b456bda2803eb6e0bc907d2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables timer by setting "TE" bit in the CTRL register to 1.  <br /></td></tr>
<tr class="separator:a03bb5b7b456bda2803eb6e0bc907d2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e09ad517a12af2d293982a1e0f2d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a55e09ad517a12af2d293982a1e0f2d0d">EF_TMR32_disable</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:a55e09ad517a12af2d293982a1e0f2d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables timer by setting "TE" bit in the CTRL register to 0.  <br /></td></tr>
<tr class="separator:a55e09ad517a12af2d293982a1e0f2d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eefc74b17c0183939742ab664fe84db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a5eefc74b17c0183939742ab664fe84db">EF_TMR32_restart</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:a5eefc74b17c0183939742ab664fe84db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables timer re-start; used in the one-shot mode to restart the timer by setting the "TS" bit in the CTRL register to 1 and then to 0.  <br /></td></tr>
<tr class="separator:a5eefc74b17c0183939742ab664fe84db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eb34d261146ff2dbb5b1765309fb10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a34eb34d261146ff2dbb5b1765309fb10">EF_TMR32_PWM0Enable</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:a34eb34d261146ff2dbb5b1765309fb10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables PWM0 by setting "P0E" bit in the CTRL register to 1.  <br /></td></tr>
<tr class="separator:a34eb34d261146ff2dbb5b1765309fb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbae8bfd22ccc3ada22d403e22274850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#acbae8bfd22ccc3ada22d403e22274850">EF_TMR32_PWM1Enable</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:acbae8bfd22ccc3ada22d403e22274850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables PWM1 by setting "P1E" bit in the CTRL register to 1.  <br /></td></tr>
<tr class="separator:acbae8bfd22ccc3ada22d403e22274850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab370a4c58f42c489a93651d180f99423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ab370a4c58f42c489a93651d180f99423">EF_TMR32_PWMDeadtimeEnable</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="separator:ab370a4c58f42c489a93651d180f99423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d78069423fc1b6c251f8ec9df10c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#aa6d78069423fc1b6c251f8ec9df10c48">EF_TMR32_PWM0Invert</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:aa6d78069423fc1b6c251f8ec9df10c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts PWM0 output by setting "P0I" bit in the CTRL register to 1.  <br /></td></tr>
<tr class="separator:aa6d78069423fc1b6c251f8ec9df10c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a9f7c2610d376d309cd29de1c317ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a53a9f7c2610d376d309cd29de1c317ce">EF_TMR32_PWM1Invert</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:a53a9f7c2610d376d309cd29de1c317ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts PWM1 output by setting "P1I" bit in the CTRL register to 1.  <br /></td></tr>
<tr class="separator:a53a9f7c2610d376d309cd29de1c317ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb3f68daef94e6e3668a88eea378fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#aadb3f68daef94e6e3668a88eea378fd2">EF_TMR32_setUpCount</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:aadb3f68daef94e6e3668a88eea378fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timer direction to be up counting by setting the "DIR" field in the CTRL register to 0b10.  <br /></td></tr>
<tr class="separator:aadb3f68daef94e6e3668a88eea378fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731ce7ebd98193b110862471c45e6d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a731ce7ebd98193b110862471c45e6d40">EF_TMR32_setDownCount</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:a731ce7ebd98193b110862471c45e6d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timer direction to be down counting by setting the "DIR" field in the CTRL register to 0b01.  <br /></td></tr>
<tr class="separator:a731ce7ebd98193b110862471c45e6d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd6766483cd71135ff6ba22f0af2e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a2fd6766483cd71135ff6ba22f0af2e81">EF_TMR32_setUpDownCount</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:a2fd6766483cd71135ff6ba22f0af2e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timer direction to be up/down counting by setting the "DIR" field in the CTRL register to 0b11.  <br /></td></tr>
<tr class="separator:a2fd6766483cd71135ff6ba22f0af2e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b99e7a248aa01794677de568a89c12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ae1b99e7a248aa01794677de568a89c12">EF_TMR32_setPeriodic</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:ae1b99e7a248aa01794677de568a89c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timer to operate in periodic mode by setting the "P" bit in the CFG register to 1.  <br /></td></tr>
<tr class="separator:ae1b99e7a248aa01794677de568a89c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab013c8ef6cdc697401cadb1351d42379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ab013c8ef6cdc697401cadb1351d42379">EF_TMR32_setOneShot</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32)</td></tr>
<tr class="memdesc:ab013c8ef6cdc697401cadb1351d42379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timer to operate in one-shot mode by clearing the "P" bit in the CFG register to 0.  <br /></td></tr>
<tr class="separator:ab013c8ef6cdc697401cadb1351d42379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f73741bff7231eb72696b642dd5344e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a6f73741bff7231eb72696b642dd5344e">EF_TMR32_setPWM0MatchingZeroAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a6f73741bff7231eb72696b642dd5344e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5329cef22cac7e6d808f69a3c5edc851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a5329cef22cac7e6d808f69a3c5edc851">EF_TMR32_setPWM0MatchingCMPXUpCountAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a5329cef22cac7e6d808f69a3c5edc851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cca84ee8407a02efa49d1ad4357cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a02cca84ee8407a02efa49d1ad4357cdc">EF_TMR32_setPWM0MatchingCMPYUpCountAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a02cca84ee8407a02efa49d1ad4357cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80c062a5bd682ba94d93a563c58a08b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ab80c062a5bd682ba94d93a563c58a08b">EF_TMR32_setPWM0MatchingRELOADAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:ab80c062a5bd682ba94d93a563c58a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad800e1b9441665d57d2c11f57232778c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ad800e1b9441665d57d2c11f57232778c">EF_TMR32_setPWM0MatchingCMPYDownCountAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:ad800e1b9441665d57d2c11f57232778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ceb938a22a090ae7907e013d026dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a9e7ceb938a22a090ae7907e013d026dd">EF_TMR32_setPWM0MatchingCMPXDownCountAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a9e7ceb938a22a090ae7907e013d026dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e80ed5c92214b2858766e0d8b233008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a2e80ed5c92214b2858766e0d8b233008">EF_TMR32_setPWM1MatchingZeroAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a2e80ed5c92214b2858766e0d8b233008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e27b3011128b05f745f22f7f8381464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a0e27b3011128b05f745f22f7f8381464">EF_TMR32_setPWM1MatchingCMPXUpCountingAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a0e27b3011128b05f745f22f7f8381464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9656b5c30e601673caa747caeb51c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#afc9656b5c30e601673caa747caeb51c1">EF_TMR32_setPWM1MatchingCMPYUpCountingAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:afc9656b5c30e601673caa747caeb51c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401ddd8eb0f58c2e154b0e4bed3bc4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a401ddd8eb0f58c2e154b0e4bed3bc4a2">EF_TMR32_setPWM1MatchingRELOADAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a401ddd8eb0f58c2e154b0e4bed3bc4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd40d43dac4fee39dbe7717ee848ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a3dd40d43dac4fee39dbe7717ee848ecd">EF_TMR32_setPWM1MatchingCMPYDownCountAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:a3dd40d43dac4fee39dbe7717ee848ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad579dc1e3910c7b4a78cde1e6e14bf8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#ad579dc1e3910c7b4a78cde1e6e14bf8d">EF_TMR32_setPWM1MatchingCMPXDownCountAction</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t action)</td></tr>
<tr class="separator:ad579dc1e3910c7b4a78cde1e6e14bf8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd014cbe453c7e9ad161bb95c1a5478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a5dd014cbe453c7e9ad161bb95c1a5478">EF_TMR32_setRELOAD</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t value)</td></tr>
<tr class="memdesc:a5dd014cbe453c7e9ad161bb95c1a5478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the reload value of a 32-bit timer by writing to the RELOAD register.  <br /></td></tr>
<tr class="separator:a5dd014cbe453c7e9ad161bb95c1a5478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccde6a4fe0321b995105032abce58a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a7ccde6a4fe0321b995105032abce58a6">EF_TMR32_setCMPX</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t value)</td></tr>
<tr class="memdesc:a7ccde6a4fe0321b995105032abce58a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compare value of a 32-bit timer by writing to the CMPX register.  <br /></td></tr>
<tr class="separator:a7ccde6a4fe0321b995105032abce58a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025b4b548381e4d01e729cb69b5dff3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a025b4b548381e4d01e729cb69b5dff3b">EF_TMR32_setCMPY</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t value)</td></tr>
<tr class="memdesc:a025b4b548381e4d01e729cb69b5dff3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the compare value Y of a 32-bit timer by writing to the CMPY register.  <br /></td></tr>
<tr class="separator:a025b4b548381e4d01e729cb69b5dff3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0942ecf91efd6f92a22f9881f9b67f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a6c0942ecf91efd6f92a22f9881f9b67f">EF_TMR32_getTMR</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t *tmr_value)</td></tr>
<tr class="memdesc:a6c0942ecf91efd6f92a22f9881f9b67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current timer value by reading the TMR register.  <br /></td></tr>
<tr class="separator:a6c0942ecf91efd6f92a22f9881f9b67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b86f3fe84a2823f619704f49df51ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a09b86f3fe84a2823f619704f49df51ff">EF_TMR32_setPWMDeadtime</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t value)</td></tr>
<tr class="memdesc:a09b86f3fe84a2823f619704f49df51ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM dead time value of the PWM by writing to the PWMDT register.  <br /></td></tr>
<tr class="separator:a09b86f3fe84a2823f619704f49df51ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fe49ae5e93539f493d0640328b043a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a08fe49ae5e93539f493d0640328b043a">EF_TMR32_setPR</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t value)</td></tr>
<tr class="memdesc:a08fe49ae5e93539f493d0640328b043a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the prescaler value of the timer by writing to the PR register.  <br /></td></tr>
<tr class="separator:a08fe49ae5e93539f493d0640328b043a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4376fe59b65a50ea12ebfcafd94009d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a4376fe59b65a50ea12ebfcafd94009d5">EF_TMR32_getRIS</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t *RIS_value)</td></tr>
<tr class="memdesc:a4376fe59b65a50ea12ebfcafd94009d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the raw interrupt status by reading the RIS register.  <br /></td></tr>
<tr class="separator:a4376fe59b65a50ea12ebfcafd94009d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb8df82868dfa705cd0ee26679045e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a7eb8df82868dfa705cd0ee26679045e7">EF_TMR32_getMIS</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t *MIS_value)</td></tr>
<tr class="memdesc:a7eb8df82868dfa705cd0ee26679045e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the masked interrupt status by reading the MIS register.  <br /></td></tr>
<tr class="separator:a7eb8df82868dfa705cd0ee26679045e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88702cef6eafdb625b8392d9aa58fa11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a88702cef6eafdb625b8392d9aa58fa11">EF_TMR32_setIM</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t mask)</td></tr>
<tr class="memdesc:a88702cef6eafdb625b8392d9aa58fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt mask of the timer by writing to the IM register.  <br /></td></tr>
<tr class="separator:a88702cef6eafdb625b8392d9aa58fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44163e96761725c077d3ea36ec17207d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a44163e96761725c077d3ea36ec17207d">EF_TMR32_getIM</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t *IM_value)</td></tr>
<tr class="memdesc:a44163e96761725c077d3ea36ec17207d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the interrupt clear register by reading the ICR register.  <br /></td></tr>
<tr class="separator:a44163e96761725c077d3ea36ec17207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2de51a604e7beb66db426098b7be79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a8f2de51a604e7beb66db426098b7be79">EF_TMR32_setICR</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t mask)</td></tr>
<tr class="memdesc:a8f2de51a604e7beb66db426098b7be79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interrupt clear register of the timer by writing to the ICR register.  <br /></td></tr>
<tr class="separator:a8f2de51a604e7beb66db426098b7be79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4d907e326c073a96a28e8317fc26bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a8d4d907e326c073a96a28e8317fc26bd">EF_TMR32_setPWM0EdgeAlignmentMode</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t reload_value, uint32_t duty_cycle)</td></tr>
<tr class="memdesc:a8d4d907e326c073a96a28e8317fc26bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM0 edge alignment mode.  <br /></td></tr>
<tr class="separator:a8d4d907e326c073a96a28e8317fc26bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56341d8e521f6b5001cddf60b93fe6f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a56341d8e521f6b5001cddf60b93fe6f1">EF_TMR32_setPWM1EdgeAlignmentMode</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t reload_value, uint32_t duty_cycle)</td></tr>
<tr class="memdesc:a56341d8e521f6b5001cddf60b93fe6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM1 edge alignment mode.  <br /></td></tr>
<tr class="separator:a56341d8e521f6b5001cddf60b93fe6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42492b716fb008dd6980193e039a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a0a42492b716fb008dd6980193e039a17">EF_TMR32_setPWM0CenterAlignedMode</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t reload_value, uint32_t cmpX_value)</td></tr>
<tr class="memdesc:a0a42492b716fb008dd6980193e039a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM0 center-aligned mode.  <br /></td></tr>
<tr class="separator:a0a42492b716fb008dd6980193e039a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5142ccf9f3a4ecd336c6e9364712dffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_e_f___t_m_r32_8h.html#a5142ccf9f3a4ecd336c6e9364712dffd">EF_TMR32_setPWM1CenterAlignedMode</a> (<a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> tmr32, uint32_t reload_value, uint32_t cmpY_value)</td></tr>
<tr class="memdesc:a5142ccf9f3a4ecd336c6e9364712dffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PWM1 center-aligned mode.  <br /></td></tr>
<tr class="separator:a5142ccf9f3a4ecd336c6e9364712dffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C header file for TMR32 APIs which contains the function prototypes. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af7ddd00225eb38cfb28c11b42c6842da" name="af7ddd00225eb38cfb28c11b42c6842da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ddd00225eb38cfb28c11b42c6842da">&#9670;&#160;</a></span>EF_TMR32_ACTION_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_ACTION_HIGH&#160;&#160;&#160;((uint32_t)2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output to HIGH when match occurs. </p>

</div>
</div>
<a id="a9b3631ac6d9073e4afc9b5fa08752e42" name="a9b3631ac6d9073e4afc9b5fa08752e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3631ac6d9073e4afc9b5fa08752e42">&#9670;&#160;</a></span>EF_TMR32_ACTION_INVERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_ACTION_INVERT&#160;&#160;&#160;((uint32_t)3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the output when match occurs. </p>

</div>
</div>
<a id="acb4dffaa5d4c81e7a4ecae477515e6e9" name="acb4dffaa5d4c81e7a4ecae477515e6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4dffaa5d4c81e7a4ecae477515e6e9">&#9670;&#160;</a></span>EF_TMR32_ACTION_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_ACTION_LOW&#160;&#160;&#160;((uint32_t)1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output to LOW when match occurs. </p>

</div>
</div>
<a id="af8714853a34747e7e89112230119eb61" name="af8714853a34747e7e89112230119eb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8714853a34747e7e89112230119eb61">&#9670;&#160;</a></span>EF_TMR32_ACTION_MAX_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_ACTION_MAX_VALUE&#160;&#160;&#160;((uint32_t)3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value for the action field. </p>

</div>
</div>
<a id="a50ad781adeb21f9afdae64c87995dae4" name="a50ad781adeb21f9afdae64c87995dae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ad781adeb21f9afdae64c87995dae4">&#9670;&#160;</a></span>EF_TMR32_ACTION_NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_ACTION_NONE&#160;&#160;&#160;((uint32_t)0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No action on match (do nothing) </p>

</div>
</div>
<a id="ad36eec137696cf3d46efd03cf50103b4" name="ad36eec137696cf3d46efd03cf50103b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36eec137696cf3d46efd03cf50103b4">&#9670;&#160;</a></span>EF_TMR32_ICR_MAX_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_ICR_MAX_VALUE&#160;&#160;&#160;((uint32_t)2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value for the ICR register. </p>

</div>
</div>
<a id="a8be953bc2d144836bc6f331f716e980a" name="a8be953bc2d144836bc6f331f716e980a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be953bc2d144836bc6f331f716e980a">&#9670;&#160;</a></span>EF_TMR32_IM_MAX_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_IM_MAX_VALUE&#160;&#160;&#160;((uint32_t)2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value for the IM register. </p>

</div>
</div>
<a id="a86db56e37fbb384e261a39f05208baa3" name="a86db56e37fbb384e261a39f05208baa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86db56e37fbb384e261a39f05208baa3">&#9670;&#160;</a></span>EF_TMR32_PR_MAX_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_PR_MAX_VALUE&#160;&#160;&#160;((uint32_t)0x0000FFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value for the PR register. </p>

</div>
</div>
<a id="ab645d9ca5f1c71739678d22149dd0404" name="ab645d9ca5f1c71739678d22149dd0404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab645d9ca5f1c71739678d22149dd0404">&#9670;&#160;</a></span>EF_TMR32_PWMDT_MAX_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EF_TMR32_PWMDT_MAX_VALUE&#160;&#160;&#160;((uint32_t)0x000000FF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value for the deadtime register. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a55e09ad517a12af2d293982a1e0f2d0d" name="a55e09ad517a12af2d293982a1e0f2d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e09ad517a12af2d293982a1e0f2d0d">&#9670;&#160;</a></span>EF_TMR32_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables timer by setting "TE" bit in the CTRL register to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a03bb5b7b456bda2803eb6e0bc907d2b4" name="a03bb5b7b456bda2803eb6e0bc907d2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03bb5b7b456bda2803eb6e0bc907d2b4">&#9670;&#160;</a></span>EF_TMR32_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables timer by setting "TE" bit in the CTRL register to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a44163e96761725c077d3ea36ec17207d" name="a44163e96761725c077d3ea36ec17207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44163e96761725c077d3ea36ec17207d">&#9670;&#160;</a></span>EF_TMR32_getIM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_getIM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>IM_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the interrupt clear register by reading the ICR register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IM_value</td><td>A pointer to a uint32_t where the interrupt clear value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a7eb8df82868dfa705cd0ee26679045e7" name="a7eb8df82868dfa705cd0ee26679045e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb8df82868dfa705cd0ee26679045e7">&#9670;&#160;</a></span>EF_TMR32_getMIS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_getMIS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>MIS_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the masked interrupt status by reading the MIS register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">MIS_value</td><td>A pointer to a uint32_t where the masked interrupt status value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a4376fe59b65a50ea12ebfcafd94009d5" name="a4376fe59b65a50ea12ebfcafd94009d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4376fe59b65a50ea12ebfcafd94009d5">&#9670;&#160;</a></span>EF_TMR32_getRIS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_getRIS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>RIS_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the raw interrupt status by reading the RIS register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RIS_value</td><td>A pointer to a uint32_t where the raw interrupt status value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a6c0942ecf91efd6f92a22f9881f9b67f" name="a6c0942ecf91efd6f92a22f9881f9b67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0942ecf91efd6f92a22f9881f9b67f">&#9670;&#160;</a></span>EF_TMR32_getTMR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_getTMR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>tmr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current timer value by reading the TMR register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tmr_value</td><td>A pointer to a uint32_t where the timer value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a34eb34d261146ff2dbb5b1765309fb10" name="a34eb34d261146ff2dbb5b1765309fb10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34eb34d261146ff2dbb5b1765309fb10">&#9670;&#160;</a></span>EF_TMR32_PWM0Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_PWM0Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables PWM0 by setting "P0E" bit in the CTRL register to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="aa6d78069423fc1b6c251f8ec9df10c48" name="aa6d78069423fc1b6c251f8ec9df10c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d78069423fc1b6c251f8ec9df10c48">&#9670;&#160;</a></span>EF_TMR32_PWM0Invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_PWM0Invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts PWM0 output by setting "P0I" bit in the CTRL register to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="acbae8bfd22ccc3ada22d403e22274850" name="acbae8bfd22ccc3ada22d403e22274850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbae8bfd22ccc3ada22d403e22274850">&#9670;&#160;</a></span>EF_TMR32_PWM1Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_PWM1Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables PWM1 by setting "P1E" bit in the CTRL register to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a53a9f7c2610d376d309cd29de1c317ce" name="a53a9f7c2610d376d309cd29de1c317ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a9f7c2610d376d309cd29de1c317ce">&#9670;&#160;</a></span>EF_TMR32_PWM1Invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_PWM1Invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts PWM1 output by setting "P1I" bit in the CTRL register to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="ab370a4c58f42c489a93651d180f99423" name="ab370a4c58f42c489a93651d180f99423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab370a4c58f42c489a93651d180f99423">&#9670;&#160;</a></span>EF_TMR32_PWMDeadtimeEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_PWMDeadtimeEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables PWM dead-time by setting the "DTE" (Dead-Time Enable) bit in the CTRL register to 1. Dead-time is a critical feature in PWM signal generation used to ensure a safe period between switching the high and low states, preventing short circuits or other issues in systems with complementary outputs, such as H-bridge drivers. When enabled, the "DTE" bit introduces a fixed delay between the switching of PWM channels to allow for this safety margin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a5eefc74b17c0183939742ab664fe84db" name="a5eefc74b17c0183939742ab664fe84db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eefc74b17c0183939742ab664fe84db">&#9670;&#160;</a></span>EF_TMR32_restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables timer re-start; used in the one-shot mode to restart the timer by setting the "TS" bit in the CTRL register to 1 and then to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a7ccde6a4fe0321b995105032abce58a6" name="a7ccde6a4fe0321b995105032abce58a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccde6a4fe0321b995105032abce58a6">&#9670;&#160;</a></span>EF_TMR32_setCMPX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setCMPX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the compare value of a 32-bit timer by writing to the CMPX register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The compare value to set in the CMPX register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a025b4b548381e4d01e729cb69b5dff3b" name="a025b4b548381e4d01e729cb69b5dff3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025b4b548381e4d01e729cb69b5dff3b">&#9670;&#160;</a></span>EF_TMR32_setCMPY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setCMPY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the compare value Y of a 32-bit timer by writing to the CMPY register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The compare value to set in the CMPY register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a731ce7ebd98193b110862471c45e6d40" name="a731ce7ebd98193b110862471c45e6d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731ce7ebd98193b110862471c45e6d40">&#9670;&#160;</a></span>EF_TMR32_setDownCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setDownCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timer direction to be down counting by setting the "DIR" field in the CTRL register to 0b01. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a48fee3ba105edc1dcee550925ac90f6d" name="a48fee3ba105edc1dcee550925ac90f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fee3ba105edc1dcee550925ac90f6d">&#9670;&#160;</a></span>EF_TMR32_setGclkEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setGclkEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the GCLK enable bit in the UART register to a certain value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the GCLK enable bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a8f2de51a604e7beb66db426098b7be79" name="a8f2de51a604e7beb66db426098b7be79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2de51a604e7beb66db426098b7be79">&#9670;&#160;</a></span>EF_TMR32_setICR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setICR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt clear register of the timer by writing to the ICR register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>The interrupt clear mask value to set in the ICR register. Must not exceed <a class="el" href="_e_f___t_m_r32_8h.html#ad36eec137696cf3d46efd03cf50103b4">EF_TMR32_ICR_MAX_VALUE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a88702cef6eafdb625b8392d9aa58fa11" name="a88702cef6eafdb625b8392d9aa58fa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88702cef6eafdb625b8392d9aa58fa11">&#9670;&#160;</a></span>EF_TMR32_setIM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setIM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interrupt mask of the timer by writing to the IM register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>The interrupt mask value to set in the IM register. Must not exceed <a class="el" href="_e_f___t_m_r32_8h.html#a8be953bc2d144836bc6f331f716e980a">EF_TMR32_IM_MAX_VALUE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="ab013c8ef6cdc697401cadb1351d42379" name="ab013c8ef6cdc697401cadb1351d42379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab013c8ef6cdc697401cadb1351d42379">&#9670;&#160;</a></span>EF_TMR32_setOneShot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setOneShot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timer to operate in one-shot mode by clearing the "P" bit in the CFG register to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="ae1b99e7a248aa01794677de568a89c12" name="ae1b99e7a248aa01794677de568a89c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b99e7a248aa01794677de568a89c12">&#9670;&#160;</a></span>EF_TMR32_setPeriodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPeriodic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timer to operate in periodic mode by setting the "P" bit in the CFG register to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a08fe49ae5e93539f493d0640328b043a" name="a08fe49ae5e93539f493d0640328b043a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fe49ae5e93539f493d0640328b043a">&#9670;&#160;</a></span>EF_TMR32_setPR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the prescaler value of the timer by writing to the PR register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The prescaler value to set in the PR register. Must not exceed <a class="el" href="_e_f___t_m_r32_8h.html#a86db56e37fbb384e261a39f05208baa3">EF_TMR32_PR_MAX_VALUE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a0a42492b716fb008dd6980193e039a17" name="a0a42492b716fb008dd6980193e039a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a42492b716fb008dd6980193e039a17">&#9670;&#160;</a></span>EF_TMR32_setPWM0CenterAlignedMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0CenterAlignedMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reload_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmpX_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM0 center-aligned mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reload_value</td><td>The reload value to set in the PWM0CFG register. This determines the period of the PWM signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmpX_value</td><td>The value to set in the CMPX register. This value controls the point at which the PWM signal transitions from high to low (or vice versa) in the center-aligned mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code.<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL.</li>
</ul>
</dd></dl>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with center-alignment on PWM0. It sets the timer to up-down counting mode and periodic mode, configures the zero and compare actions, and sets the reload and compare values as specified.</p>
<p>Internal configurations performed by the function:</p><ul>
<li>Sets the timer to up-down counting mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the X compare register to drive the PWM output low on up-count.</li>
<li>Configures the X compare register to drive the PWM output high on down-count.</li>
<li>Configures the Y compare register to maintain the current output state on both up and down counts.</li>
<li>Sets the reload value to define the PWM signal period.</li>
<li>Sets the X compare register value to define the transition point.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|\</div>
<div class="line">|_____/__|__\</div>
<div class="line">|   / |  |  | \</div>
<div class="line">|_/___|__|__|___\__</div>
<div class="line">      |     |</div>
<div class="line">      V     V</div>
<div class="line">  ____       ____</div>
<div class="line">      |_____|    </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings. </dd>
<dd>
for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </dd></dl>

</div>
</div>
<a id="a8d4d907e326c073a96a28e8317fc26bd" name="a8d4d907e326c073a96a28e8317fc26bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4d907e326c073a96a28e8317fc26bd">&#9670;&#160;</a></span>EF_TMR32_setPWM0EdgeAlignmentMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0EdgeAlignmentMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reload_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>duty_cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM0 edge alignment mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reload_value</td><td>The reload value to set in the PWM0CFG register. This determines the period of the PWM signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duty_cycle</td><td>The duty cycle value to set in the PWM0CFG register, representing the high time as a percentage of the period (0 to 100).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code.<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL or <code>duty_cycle</code> &gt; 100.</li>
</ul>
</dd></dl>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with edge alignment. It sets the timer to up-count and periodic modes, configures the zero action to high, and uses the X compare register to control the output signal. The duty cycle and reload values are used to compute the compare register value.</p>
<p>Internal configurations performed by the function:</p><ul>
<li>Sets the timer to up-count mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the X compare register to drive the PWM output low on up-count.</li>
<li>Configures the Y compare register to maintain the current output state.</li>
<li>Calculates the X compare value based on the duty cycle and reload value.</li>
<li>Sets the reload value and compare register.</li>
<li>Ensures no change in output on the top action.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|      /|</div>
<div class="line">|_____/__|____/  |</div>
<div class="line">|   / |  |  / |  |</div>
<div class="line">|_/___|__|/___|__|____</div>
<div class="line">      |       |</div>
<div class="line">      V       V</div>
<div class="line">  ____    ____    ___   ___</div>
<div class="line">      |__|    |__|   |__|</div>
<div class="line">  duty    duty</div>
<div class="line">  cycle   cycle</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings. </dd>
<dd>
for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </dd></dl>

</div>
</div>
<a id="a9e7ceb938a22a090ae7907e013d026dd" name="a9e7ceb938a22a090ae7907e013d026dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7ceb938a22a090ae7907e013d026dd">&#9670;&#160;</a></span>EF_TMR32_setPWM0MatchingCMPXDownCountAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0MatchingCMPXDownCountAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR0 PWM when the timer matches the CMPX value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E5_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPX value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a5329cef22cac7e6d808f69a3c5edc851" name="a5329cef22cac7e6d808f69a3c5edc851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5329cef22cac7e6d808f69a3c5edc851">&#9670;&#160;</a></span>EF_TMR32_setPWM0MatchingCMPXUpCountAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0MatchingCMPXUpCountAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR0 PWM when the timer matches the CMPX value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E1_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPX value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="ad800e1b9441665d57d2c11f57232778c" name="ad800e1b9441665d57d2c11f57232778c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad800e1b9441665d57d2c11f57232778c">&#9670;&#160;</a></span>EF_TMR32_setPWM0MatchingCMPYDownCountAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0MatchingCMPYDownCountAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR0 PWM when the timer matches the CMPY value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E4_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPY value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a02cca84ee8407a02efa49d1ad4357cdc" name="a02cca84ee8407a02efa49d1ad4357cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cca84ee8407a02efa49d1ad4357cdc">&#9670;&#160;</a></span>EF_TMR32_setPWM0MatchingCMPYUpCountAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0MatchingCMPYUpCountAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR0 PWM when the timer matches the CMPY value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E2_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPY value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="ab80c062a5bd682ba94d93a563c58a08b" name="ab80c062a5bd682ba94d93a563c58a08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80c062a5bd682ba94d93a563c58a08b">&#9670;&#160;</a></span>EF_TMR32_setPWM0MatchingRELOADAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0MatchingRELOADAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR0 PWM when the timer matches the RELOAD value. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the RELOAD value. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E3_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the RELOAD value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a6f73741bff7231eb72696b642dd5344e" name="a6f73741bff7231eb72696b642dd5344e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f73741bff7231eb72696b642dd5344e">&#9670;&#160;</a></span>EF_TMR32_setPWM0MatchingZeroAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM0MatchingZeroAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR0 PWM when the timer matches the Zero value. This function allows the user to specify what happens to the PWM output signal when the timer counter reaches zero. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying <a class="el" href="_e_f___t_m_r32__regs_8h.html#a70b01f1d7aaa6ec37fec28ffe7d49b1b">EF_TMR32_PWM0CFG_REG_E0_BIT</a>. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the Zero value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a5142ccf9f3a4ecd336c6e9364712dffd" name="a5142ccf9f3a4ecd336c6e9364712dffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5142ccf9f3a4ecd336c6e9364712dffd">&#9670;&#160;</a></span>EF_TMR32_setPWM1CenterAlignedMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1CenterAlignedMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reload_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmpY_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM1 center-aligned mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reload_value</td><td>The reload value to set in the PWM1CFG register. This determines the period of the PWM signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmpY_value</td><td>The value to set in the CMPX register. This value controls the point at which the PWM signal transitions from high to low (or vice versa) in the center-aligned mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code.<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL.</li>
</ul>
</dd></dl>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with center-alignment on PWM1. It sets the timer to up-down counting mode and periodic mode, configures the zero and compare actions, and sets the reload and compare values as specified.</p>
<p>Internal configurations performed by the function:</p><ul>
<li>Sets the timer to up-down counting mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the Y compare register to drive the PWM output low on up-count.</li>
<li>Configures the Y compare register to drive the PWM output high on down-count.</li>
<li>Configures the X compare register to maintain the current output state on both up and down counts.</li>
<li>Sets the reload value to define the PWM signal period.</li>
<li>Sets the X compare register value to define the transition point.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|\</div>
<div class="line">|_____/__|__\</div>
<div class="line">|   / |  |  | \</div>
<div class="line">|_/___|__|__|___\__</div>
<div class="line">      |     |</div>
<div class="line">      V     V</div>
<div class="line">  ____       ____ </div>
<div class="line">      |_____|    </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings. </dd>
<dd>
for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </dd></dl>

</div>
</div>
<a id="a56341d8e521f6b5001cddf60b93fe6f1" name="a56341d8e521f6b5001cddf60b93fe6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56341d8e521f6b5001cddf60b93fe6f1">&#9670;&#160;</a></span>EF_TMR32_setPWM1EdgeAlignmentMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1EdgeAlignmentMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reload_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>duty_cycle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM1 edge alignment mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reload_value</td><td>The reload value to set in the PWM1CFG register. This determines the period of the PWM signal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">duty_cycle</td><td>The duty cycle value to set in the PWM1CFG register, representing the high time as a percentage of the period (0 to 100).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code.<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL or <code>duty_cycle</code> &gt; 100.</li>
</ul>
</dd></dl>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with edge alignment on PWM1. It sets the timer to up-count and periodic modes, configures the zero action to high, and uses the Y compare register to control the output signal. The duty cycle and reload values are used to compute the compare register value.</p>
<p>Internal configurations performed by the function:</p><ul>
<li>Sets the timer to up-count mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the Y compare register to drive the PWM output low on up-count.</li>
<li>Configures the X compare register to maintain the current output state.</li>
<li>Calculates the Y compare value based on the duty cycle and reload value.</li>
<li>Sets the reload value and compare register.</li>
<li>Ensures no change in output on the top action.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|      /|</div>
<div class="line">|_____/__|____/  |</div>
<div class="line">|   / |  |  / |  |</div>
<div class="line">|_/___|__|/___|__|____</div>
<div class="line">      |       |</div>
<div class="line">      V       V</div>
<div class="line">  ____    ____    ___   ___</div>
<div class="line">      |__|    |__|   |__|</div>
<div class="line">  duty    duty</div>
<div class="line">  cycle   cycle</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings. </dd>
<dd>
for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </dd></dl>

</div>
</div>
<a id="ad579dc1e3910c7b4a78cde1e6e14bf8d" name="ad579dc1e3910c7b4a78cde1e6e14bf8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad579dc1e3910c7b4a78cde1e6e14bf8d">&#9670;&#160;</a></span>EF_TMR32_setPWM1MatchingCMPXDownCountAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1MatchingCMPXDownCountAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR1 PWM when the timer matches the CMPX value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E5_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPX value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a0e27b3011128b05f745f22f7f8381464" name="a0e27b3011128b05f745f22f7f8381464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e27b3011128b05f745f22f7f8381464">&#9670;&#160;</a></span>EF_TMR32_setPWM1MatchingCMPXUpCountingAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1MatchingCMPXUpCountingAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR1 PWM when the timer matches the CMPX value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E1_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPX value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a3dd40d43dac4fee39dbe7717ee848ecd" name="a3dd40d43dac4fee39dbe7717ee848ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd40d43dac4fee39dbe7717ee848ecd">&#9670;&#160;</a></span>EF_TMR32_setPWM1MatchingCMPYDownCountAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1MatchingCMPYDownCountAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR1 PWM when the timer matches the CMPY value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E4_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPY value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="afc9656b5c30e601673caa747caeb51c1" name="afc9656b5c30e601673caa747caeb51c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9656b5c30e601673caa747caeb51c1">&#9670;&#160;</a></span>EF_TMR32_setPWM1MatchingCMPYUpCountingAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1MatchingCMPYUpCountingAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR1 PWM when the timer matches the CMPY value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E2_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the CMPY value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a401ddd8eb0f58c2e154b0e4bed3bc4a2" name="a401ddd8eb0f58c2e154b0e4bed3bc4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a401ddd8eb0f58c2e154b0e4bed3bc4a2">&#9670;&#160;</a></span>EF_TMR32_setPWM1MatchingRELOADAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1MatchingRELOADAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR1 PWM when the timer matches the RELOAD value. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the RELOAD value. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E3_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the RELOAD value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a2e80ed5c92214b2858766e0d8b233008" name="a2e80ed5c92214b2858766e0d8b233008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e80ed5c92214b2858766e0d8b233008">&#9670;&#160;</a></span>EF_TMR32_setPWM1MatchingZeroAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWM1MatchingZeroAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the action of TMR1 PWM when the timer matches the Zero value. This function allows the user to specify what happens to the PWM output signal when the timer counter reaches zero. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying <a class="el" href="_e_f___t_m_r32__regs_8h.html#ad50501bb2385f55df3c6d9b5ef78c5bf">EF_TMR32_PWM1CFG_REG_E0_BIT</a>. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">action</td><td>A uint32_t value specifying the action to take when the timer matches the Zero value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a09b86f3fe84a2823f619704f49df51ff" name="a09b86f3fe84a2823f619704f49df51ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b86f3fe84a2823f619704f49df51ff">&#9670;&#160;</a></span>EF_TMR32_setPWMDeadtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setPWMDeadtime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the PWM dead time value of the PWM by writing to the PWMDT register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The dead time value to set in the PWMDT register. Must not exceed <a class="el" href="_e_f___t_m_r32_8h.html#ab645d9ca5f1c71739678d22149dd0404">EF_TMR32_PWMDT_MAX_VALUE</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="a5dd014cbe453c7e9ad161bb95c1a5478" name="a5dd014cbe453c7e9ad161bb95c1a5478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd014cbe453c7e9ad161bb95c1a5478">&#9670;&#160;</a></span>EF_TMR32_setRELOAD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setRELOAD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the reload value of a 32-bit timer by writing to the RELOAD register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>, which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The reload value to set in the RELOAD register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type EF_DRIVER_STATUS: returns a success or error code. </dd></dl>

</div>
</div>
<a id="aadb3f68daef94e6e3668a88eea378fd2" name="aadb3f68daef94e6e3668a88eea378fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb3f68daef94e6e3668a88eea378fd2">&#9670;&#160;</a></span>EF_TMR32_setUpCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setUpCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timer direction to be up counting by setting the "DIR" field in the CTRL register to 0b10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
<a id="a2fd6766483cd71135ff6ba22f0af2e81" name="a2fd6766483cd71135ff6ba22f0af2e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd6766483cd71135ff6ba22f0af2e81">&#9670;&#160;</a></span>EF_TMR32_setUpDownCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> EF_TMR32_setUpDownCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>&#160;</td>
          <td class="paramname"><em>tmr32</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timer direction to be up/down counting by setting the "DIR" field in the CTRL register to 0b11. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmr32</td><td>An <a class="el" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a> , which points to the base memory address of TMR32 registers. <a class="el" href="_e_f___t_m_r32__regs_8h.html#a5ab4e3f4232149b200ef8d43a25c9082">EF_TMR32_TYPE</a> is a structure that contains the TMR32 registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status A value of type <a class="el" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> : returns a success or error code </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
