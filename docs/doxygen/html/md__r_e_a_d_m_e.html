<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EF_TMR32 APIs: API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">EF_TMR32 APIs
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">API Reference </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Header files</h1>
<ul>
<li>EF_Driver_Common.h</li>
<li>EF_TMR32.h</li>
<li>EF_TMR32_example.h</li>
<li>EF_TMR32_regs.h</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
File EF_Driver_Common.h</h1>
<p><em>C header file for common driver definitions and types.</em></p>
<h1><a class="anchor" id="autotoc_md3"></a>
Structures and Types</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadLeft">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">typedef uint32_t   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_STATUS** <br  />
<em>A type that is used to return the status of the driver functions.</em>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md4"></a>
Macros</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadLeft">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_ERROR** ((uint32_t)1)<br  />
<em>Unspecified error.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_ERROR\_BUSY** ((uint32_t)2)<br  />
<em>Driver is busy.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_ERROR\_PARAMETER** ((uint32_t)5)<br  />
<em>Parameter error.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_ERROR\_SPECIFIC** ((uint32_t)6)<br  />
<em>Start of driver specific errors.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_ERROR\_TIMEOUT** ((uint32_t)3)<br  />
<em>Timeout occurred.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_ERROR\_UNSUPPORTED** ((uint32_t)4)<br  />
<em>Operation not supported.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_DRIVER\_OK** ((uint32_t)0)<br  />
<em>Operation succeeded.</em>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md5"></a>
Structures and Types Documentation</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
typedef &lt;tt&gt;EF_DRIVER_STATUS&lt;/tt&gt;</h2>
<p><em>A type that is used to return the status of the driver functions.</em> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> uint32_t <a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a>;</div>
<div class="ttc" id="a_e_f___driver___common_8h_html_ad1c99136d1edfd0a7757f5b81600a351"><div class="ttname"><a href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a></div><div class="ttdeci">uint32_t EF_DRIVER_STATUS</div><div class="ttdoc">A type that is used to return the status of the driver functions.</div><div class="ttdef"><b>Definition:</b> EF_Driver_Common.h:53</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Macros Documentation</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
define &lt;tt&gt;EF_DRIVER_ERROR&lt;/tt&gt;</h2>
<p><em>Unspecified error.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_DRIVER_ERROR ((uint32_t)1)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
define &lt;tt&gt;EF_DRIVER_ERROR_BUSY&lt;/tt&gt;</h2>
<p><em>Driver is busy.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_DRIVER_ERROR_BUSY ((uint32_t)2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
define &lt;tt&gt;EF_DRIVER_ERROR_PARAMETER&lt;/tt&gt;</h2>
<p><em>Parameter error.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_DRIVER_ERROR_PARAMETER ((uint32_t)5)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
define &lt;tt&gt;EF_DRIVER_ERROR_SPECIFIC&lt;/tt&gt;</h2>
<p><em>Start of driver specific errors.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_DRIVER_ERROR_SPECIFIC ((uint32_t)6)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
define &lt;tt&gt;EF_DRIVER_ERROR_TIMEOUT&lt;/tt&gt;</h2>
<p><em>Timeout occurred.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_DRIVER_ERROR_TIMEOUT ((uint32_t)3)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
define &lt;tt&gt;EF_DRIVER_ERROR_UNSUPPORTED&lt;/tt&gt;</h2>
<p><em>Operation not supported.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_DRIVER_ERROR_UNSUPPORTED ((uint32_t)4)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
define &lt;tt&gt;EF_DRIVER_OK&lt;/tt&gt;</h2>
<p><em>Operation succeeded.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_DRIVER_OK ((uint32_t)0)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
File EF_TMR32.h</h1>
<p><em>C header file for TMR32 APIs which contains the function prototypes.</em></p>
<h1><a class="anchor" id="autotoc_md16"></a>
Functions</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadLeft">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0Enable** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Enables PWM0 by setting "P0E" bit in the CTRL register to 1.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0Invert** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Inverts PWM0 output by setting "P0I" bit in the CTRL register to 1.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1Enable** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Enables PWM1 by setting "P1E" bit in the CTRL register to 1.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1Invert** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Inverts PWM1 output by setting "P1I" bit in the CTRL register to 1.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWMDeadtimeEnable** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_clearCMPXMatchFlag** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Clears the CMPX match flag by writing to the ICR register and setting the MX bit.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_clearCMPYMatchFlag** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Clears the CMPY match flag by writing to the ICR register and setting the MY bit.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_clearTimoutFlag** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Clears the timeout flag by writing to the ICR register and setting the TO bit.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_disable** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Disables timer by setting "TE" bit in the CTRL register to 0.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_enable** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Enables timer by setting "TE" bit in the CTRL register to 1.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_getIM** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t *IM_value) <br  />
<em>Retrieves the interrupt clear register by reading the ICR register.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_getMIS** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t *MIS_value) <br  />
<em>Retrieves the masked interrupt status by reading the MIS register.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_getRIS** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t *RIS_value) <br  />
<em>Retrieves the raw interrupt status by reading the RIS register.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_getTMR** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t *tmr_value) <br  />
<em>Retrieves the current timer value by reading the TMR register.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_isCMPXMatch** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t *match_status) <br  />
<em>Checks if the timer has reached the CMPX value by reading the RIS register and checking the MX flag.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_isCMPYMatch** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t *match_status) <br  />
<em>Checks if the timer has reached the CMPY value by reading the RIS register and checking the MY flag.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_isTimout** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t *timeout_status) <br  />
<em>Checks if the timer has reached the RELOAD value if up counting or zero if down counting by reading the RIS register and checking the RT flag.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_restart** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Enables timer re-start; used in the one-shot mode to restart the timer by setting the "TS" bit in the CTRL register to 1 and then to 0.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setCMPX** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t value) <br  />
<em>Sets the compare value of a 32-bit timer by writing to the CMPX register.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setCMPY** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t value) <br  />
<em>Sets the compare value Y of a 32-bit timer by writing to the CMPY register.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setDownCount** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Sets the timer direction to be down counting by setting the "DIR" field in the CTRL register to 0b01.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setGclkEnable** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t value) <br  />
<em>Sets the GCLK enable bit in the UART register to a certain value.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setICR** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t mask) <br  />
<em>Sets the interrupt clear register of the timer by writing to the ICR register.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setIM** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t mask) <br  />
<em>Sets the interrupt mask of the timer by writing to the IM register.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setOneShot** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Sets the timer to operate in one-shot mode by clearing the "P" bit in the CFG register to 0.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPR** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t value) <br  />
<em>Sets the prescaler value of the timer by writing to the PR register.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0CenterAlignedMode** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t reload_value, uint32_t cmpX_value) <br  />
<em>Sets the PWM0 center-aligned mode.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0EdgeAlignmentMode** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t reload_value, uint32_t duty_cycle) <br  />
<em>Sets the PWM0 edge alignment mode.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0MatchingCMPXDownCountAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0MatchingCMPXUpCountAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0MatchingCMPYDownCountAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0MatchingCMPYUpCountAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0MatchingRELOADAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM0MatchingZeroAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1CenterAlignedMode** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t reload_value, uint32_t cmpY_value) <br  />
<em>Sets the PWM1 center-aligned mode.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1EdgeAlignmentMode** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t reload_value, uint32_t duty_cycle) <br  />
<em>Sets the PWM1 edge alignment mode.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1MatchingCMPXDownCountAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1MatchingCMPXUpCountingAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1MatchingCMPYDownCountAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1MatchingCMPYUpCountingAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1MatchingRELOADAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWM1MatchingZeroAction** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t action) <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPWMDeadtime** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t value) <br  />
<em>Sets the PWM dead time value of the PWM by writing to the PWMDT register.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setPeriodic** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Sets the timer to operate in periodic mode by setting the "P" bit in the CFG register to 1.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setRELOAD** (**EF\_TMR32\_TYPE\_PTR** tmr32, uint32_t value) <br  />
<em>Sets the reload value of a 32-bit timer by writing to the RELOAD register.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setUpCount** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Sets the timer direction to be up counting by setting the "DIR" field in the CTRL register to 0b10.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_setUpDownCount** (**EF\_TMR32\_TYPE\_PTR** tmr32) <br  />
<em>Sets the timer direction to be up/down counting by setting the "DIR" field in the CTRL register to 0b11.</em>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md17"></a>
Macros</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadLeft">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_ACTION\_HIGH** ((uint32_t)2)<br  />
<em>Set output to HIGH when match occurs.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_ACTION\_INVERT** ((uint32_t)3)<br  />
<em>Invert the output when match occurs.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_ACTION\_LOW** ((uint32_t)1)<br  />
<em>Set output to LOW when match occurs.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_ACTION\_MAX\_VALUE** ((uint32_t)3)<br  />
<em>Maximum value for the action field.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_ACTION\_NONE** ((uint32_t)0)<br  />
<em>No action on match (do nothing)</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_ICR\_MAX\_VALUE** ((uint32_t)2)<br  />
<em>Maximum value for the ICR register.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_IM\_MAX\_VALUE** ((uint32_t)2)<br  />
<em>Maximum value for the IM register.</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PR\_MAX\_VALUE** ((uint32_t)0x0000FFFF)<br  />
<em>Maximum value for the PR register.</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWMDT\_MAX\_VALUE** ((uint32_t)0x000000FF)<br  />
<em>Maximum value for the deadtime register.</em>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md18"></a>
Functions Documentation</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
function &lt;tt&gt;EF_TMR32_PWM0Enable&lt;/tt&gt;</h2>
<p><em>Enables PWM0 by setting "P0E" bit in the CTRL register to 1.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a34eb34d261146ff2dbb5b1765309fb10">EF_TMR32_PWM0Enable</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a34eb34d261146ff2dbb5b1765309fb10"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a34eb34d261146ff2dbb5b1765309fb10">EF_TMR32_PWM0Enable</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_PWM0Enable(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Enables PWM0 by setting &quot;P0E&quot; bit in the CTRL register to 1.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:110</div></div>
<div class="ttc" id="astruct___e_f___t_m_r32___t_y_p_e___html"><div class="ttname"><a href="struct___e_f___t_m_r32___t_y_p_e__.html">_EF_TMR32_TYPE_</a></div><div class="ttdef"><b>Definition:</b> EF_TMR32_regs.h:92</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md20"></a>
function &lt;tt&gt;EF_TMR32_PWM0Invert&lt;/tt&gt;</h2>
<p><em>Inverts PWM0 output by setting "P0I" bit in the CTRL register to 1.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#aa6d78069423fc1b6c251f8ec9df10c48">EF_TMR32_PWM0Invert</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_aa6d78069423fc1b6c251f8ec9df10c48"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#aa6d78069423fc1b6c251f8ec9df10c48">EF_TMR32_PWM0Invert</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_PWM0Invert(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Inverts PWM0 output by setting &quot;P0I&quot; bit in the CTRL register to 1.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:149</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md21"></a>
function &lt;tt&gt;EF_TMR32_PWM1Enable&lt;/tt&gt;</h2>
<p><em>Enables PWM1 by setting "P1E" bit in the CTRL register to 1.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#acbae8bfd22ccc3ada22d403e22274850">EF_TMR32_PWM1Enable</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_acbae8bfd22ccc3ada22d403e22274850"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#acbae8bfd22ccc3ada22d403e22274850">EF_TMR32_PWM1Enable</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_PWM1Enable(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Enables PWM1 by setting &quot;P1E&quot; bit in the CTRL register to 1.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:123</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md22"></a>
function &lt;tt&gt;EF_TMR32_PWM1Invert&lt;/tt&gt;</h2>
<p><em>Inverts PWM1 output by setting "P1I" bit in the CTRL register to 1.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a53a9f7c2610d376d309cd29de1c317ce">EF_TMR32_PWM1Invert</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a53a9f7c2610d376d309cd29de1c317ce"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a53a9f7c2610d376d309cd29de1c317ce">EF_TMR32_PWM1Invert</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_PWM1Invert(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Inverts PWM1 output by setting &quot;P1I&quot; bit in the CTRL register to 1.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:162</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md23"></a>
function &lt;tt&gt;EF_TMR32_PWMDeadtimeEnable&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ab370a4c58f42c489a93651d180f99423">EF_TMR32_PWMDeadtimeEnable</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ab370a4c58f42c489a93651d180f99423"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ab370a4c58f42c489a93651d180f99423">EF_TMR32_PWMDeadtimeEnable</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_PWMDeadtimeEnable(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:136</div></div>
</div><!-- fragment --><p>Enables PWM dead-time by setting the "DTE" (Dead-Time Enable) bit in the CTRL register to 1. Dead-time is a critical feature in PWM signal generation used to ensure a safe period between switching the high and low states, preventing short circuits or other issues in systems with complementary outputs, such as H-bridge drivers. When enabled, the "DTE" bit introduces a fixed delay between the switching of PWM channels to allow for this safety margin.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md24"></a>
function &lt;tt&gt;EF_TMR32_clearCMPXMatchFlag&lt;/tt&gt;</h2>
<p><em>Clears the CMPX match flag by writing to the ICR register and setting the MX bit.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ac5c775883fbdab72773ffd7f95d5082b">EF_TMR32_clearCMPXMatchFlag</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ac5c775883fbdab72773ffd7f95d5082b"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ac5c775883fbdab72773ffd7f95d5082b">EF_TMR32_clearCMPXMatchFlag</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_clearCMPXMatchFlag(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Clears the CMPX match flag by writing to the ICR register and setting the MX bit.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:733</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md25"></a>
function &lt;tt&gt;EF_TMR32_clearCMPYMatchFlag&lt;/tt&gt;</h2>
<p><em>Clears the CMPY match flag by writing to the ICR register and setting the MY bit.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a56a7ddce686fe3bed66388193ce2f225">EF_TMR32_clearCMPYMatchFlag</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a56a7ddce686fe3bed66388193ce2f225"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a56a7ddce686fe3bed66388193ce2f225">EF_TMR32_clearCMPYMatchFlag</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_clearCMPYMatchFlag(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Clears the CMPY match flag by writing to the ICR register and setting the MY bit.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:746</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md26"></a>
function &lt;tt&gt;EF_TMR32_clearTimoutFlag&lt;/tt&gt;</h2>
<p><em>Clears the timeout flag by writing to the ICR register and setting the TO bit.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a0e9f5f4e5f1a4b8d7805eb4dbdf70e93">EF_TMR32_clearTimoutFlag</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a0e9f5f4e5f1a4b8d7805eb4dbdf70e93"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a0e9f5f4e5f1a4b8d7805eb4dbdf70e93">EF_TMR32_clearTimoutFlag</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_clearTimoutFlag(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Clears the timeout flag by writing to the ICR register and setting the TO bit.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:721</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md27"></a>
function &lt;tt&gt;EF_TMR32_disable&lt;/tt&gt;</h2>
<p><em>Disables timer by setting "TE" bit in the CTRL register to 0.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a55e09ad517a12af2d293982a1e0f2d0d">EF_TMR32_disable</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a55e09ad517a12af2d293982a1e0f2d0d"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a55e09ad517a12af2d293982a1e0f2d0d">EF_TMR32_disable</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_disable(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Disables timer by setting &quot;TE&quot; bit in the CTRL register to 0.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:83</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md28"></a>
function &lt;tt&gt;EF_TMR32_enable&lt;/tt&gt;</h2>
<p><em>Enables timer by setting "TE" bit in the CTRL register to 1.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a03bb5b7b456bda2803eb6e0bc907d2b4">EF_TMR32_enable</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a03bb5b7b456bda2803eb6e0bc907d2b4"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a03bb5b7b456bda2803eb6e0bc907d2b4">EF_TMR32_enable</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_enable(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Enables timer by setting &quot;TE&quot; bit in the CTRL register to 1.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:70</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md29"></a>
function &lt;tt&gt;EF_TMR32_getIM&lt;/tt&gt;</h2>
<p><em>Retrieves the interrupt clear register by reading the ICR register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a44163e96761725c077d3ea36ec17207d">EF_TMR32_getIM</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t *IM_value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a44163e96761725c077d3ea36ec17207d"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a44163e96761725c077d3ea36ec17207d">EF_TMR32_getIM</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_getIM(EF_TMR32_TYPE_PTR tmr32, uint32_t *IM_value)</div><div class="ttdoc">Retrieves the interrupt clear register by reading the ICR register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:631</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>IM_value</code> A pointer to a uint32_t where the interrupt clear value will be stored.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md30"></a>
function &lt;tt&gt;EF_TMR32_getMIS&lt;/tt&gt;</h2>
<p><em>Retrieves the masked interrupt status by reading the MIS register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a7eb8df82868dfa705cd0ee26679045e7">EF_TMR32_getMIS</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t *MIS_value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a7eb8df82868dfa705cd0ee26679045e7"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a7eb8df82868dfa705cd0ee26679045e7">EF_TMR32_getMIS</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_getMIS(EF_TMR32_TYPE_PTR tmr32, uint32_t *MIS_value)</div><div class="ttdoc">Retrieves the masked interrupt status by reading the MIS register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:600</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>MIS_value</code> A pointer to a uint32_t where the masked interrupt status value will be stored.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md31"></a>
function &lt;tt&gt;EF_TMR32_getRIS&lt;/tt&gt;</h2>
<p><em>Retrieves the raw interrupt status by reading the RIS register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a4376fe59b65a50ea12ebfcafd94009d5">EF_TMR32_getRIS</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t *RIS_value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a4376fe59b65a50ea12ebfcafd94009d5"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a4376fe59b65a50ea12ebfcafd94009d5">EF_TMR32_getRIS</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_getRIS(EF_TMR32_TYPE_PTR tmr32, uint32_t *RIS_value)</div><div class="ttdoc">Retrieves the raw interrupt status by reading the RIS register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:584</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>RIS_value</code> A pointer to a uint32_t where the raw interrupt status value will be stored.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md32"></a>
function &lt;tt&gt;EF_TMR32_getTMR&lt;/tt&gt;</h2>
<p><em>Retrieves the current timer value by reading the TMR register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a6c0942ecf91efd6f92a22f9881f9b67f">EF_TMR32_getTMR</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t *tmr_value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a6c0942ecf91efd6f92a22f9881f9b67f"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a6c0942ecf91efd6f92a22f9881f9b67f">EF_TMR32_getTMR</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_getTMR(EF_TMR32_TYPE_PTR tmr32, uint32_t *tmr_value)</div><div class="ttdoc">Retrieves the current timer value by reading the TMR register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:533</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>tmr_value</code> A pointer to a uint32_t where the timer value will be stored.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md33"></a>
function &lt;tt&gt;EF_TMR32_isCMPXMatch&lt;/tt&gt;</h2>
<p><em>Checks if the timer has reached the CMPX value by reading the RIS register and checking the MX flag.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ab0aa33e92e5e3d1a1d5c2bd81b392126">EF_TMR32_isCMPXMatch</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t *match_status</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ab0aa33e92e5e3d1a1d5c2bd81b392126"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ab0aa33e92e5e3d1a1d5c2bd81b392126">EF_TMR32_isCMPXMatch</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_isCMPXMatch(EF_TMR32_TYPE_PTR tmr32, uint32_t *match_status)</div><div class="ttdoc">Checks if the timer has reached the CMPX value by reading the RIS register and checking the MX flag.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:682</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>match_status</code> A pointer to a uint32_t where the match status will be stored.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md34"></a>
function &lt;tt&gt;EF_TMR32_isCMPYMatch&lt;/tt&gt;</h2>
<p><em>Checks if the timer has reached the CMPY value by reading the RIS register and checking the MY flag.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a7d0794cbbf8270e4301fa1b3de960f6e">EF_TMR32_isCMPYMatch</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t *match_status</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a7d0794cbbf8270e4301fa1b3de960f6e"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a7d0794cbbf8270e4301fa1b3de960f6e">EF_TMR32_isCMPYMatch</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_isCMPYMatch(EF_TMR32_TYPE_PTR tmr32, uint32_t *match_status)</div><div class="ttdoc">Checks if the timer has reached the CMPY value by reading the RIS register and checking the MY flag.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:701</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>match_status</code> A pointer to a uint32_t where the match status will be stored.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md35"></a>
function &lt;tt&gt;EF_TMR32_isTimout&lt;/tt&gt;</h2>
<p><em>Checks if the timer has reached the RELOAD value if up counting or zero if down counting by reading the RIS register and checking the RT flag.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a82460d824d3cd16a7ab024676d5d2dd4">EF_TMR32_isTimout</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t *timeout_status</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a82460d824d3cd16a7ab024676d5d2dd4"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a82460d824d3cd16a7ab024676d5d2dd4">EF_TMR32_isTimout</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_isTimout(EF_TMR32_TYPE_PTR tmr32, uint32_t *timeout_status)</div><div class="ttdoc">Checks if the timer has reached the RELOAD value if up counting or zero if down counting by reading t...</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:663</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>timeout_status</code> A pointer to a uint32_t where the timeout status will be stored.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md36"></a>
function &lt;tt&gt;EF_TMR32_restart&lt;/tt&gt;</h2>
<p><em>Enables timer re-start; used in the one-shot mode to restart the timer by setting the "TS" bit in the CTRL register to 1 and then to 0.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5eefc74b17c0183939742ab664fe84db">EF_TMR32_restart</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a5eefc74b17c0183939742ab664fe84db"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a5eefc74b17c0183939742ab664fe84db">EF_TMR32_restart</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_restart(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Enables timer re-start; used in the one-shot mode to restart the timer by setting the &quot;TS&quot; bit in the...</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:96</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md37"></a>
function &lt;tt&gt;EF_TMR32_setCMPX&lt;/tt&gt;</h2>
<p><em>Sets the compare value of a 32-bit timer by writing to the CMPX register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a7ccde6a4fe0321b995105032abce58a6">EF_TMR32_setCMPX</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a7ccde6a4fe0321b995105032abce58a6"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a7ccde6a4fe0321b995105032abce58a6">EF_TMR32_setCMPX</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setCMPX(EF_TMR32_TYPE_PTR tmr32, uint32_t value)</div><div class="ttdoc">Sets the compare value of a 32-bit timer by writing to the CMPX register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:501</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>value</code> The compare value to set in the CMPX register.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md38"></a>
function &lt;tt&gt;EF_TMR32_setCMPY&lt;/tt&gt;</h2>
<p><em>Sets the compare value Y of a 32-bit timer by writing to the CMPY register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a025b4b548381e4d01e729cb69b5dff3b">EF_TMR32_setCMPY</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a025b4b548381e4d01e729cb69b5dff3b"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a025b4b548381e4d01e729cb69b5dff3b">EF_TMR32_setCMPY</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setCMPY(EF_TMR32_TYPE_PTR tmr32, uint32_t value)</div><div class="ttdoc">Sets the compare value Y of a 32-bit timer by writing to the CMPY register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:517</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>value</code> The compare value to set in the CMPY register.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md39"></a>
function &lt;tt&gt;EF_TMR32_setDownCount&lt;/tt&gt;</h2>
<p><em>Sets the timer direction to be down counting by setting the "DIR" field in the CTRL register to 0b01.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a731ce7ebd98193b110862471c45e6d40">EF_TMR32_setDownCount</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a731ce7ebd98193b110862471c45e6d40"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a731ce7ebd98193b110862471c45e6d40">EF_TMR32_setDownCount</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setDownCount(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Sets the timer direction to be down counting by setting the &quot;DIR&quot; field in the CTRL register to 0b01.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:190</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md40"></a>
function &lt;tt&gt;EF_TMR32_setGclkEnable&lt;/tt&gt;</h2>
<p><em>Sets the GCLK enable bit in the UART register to a certain value.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a48fee3ba105edc1dcee550925ac90f6d">EF_TMR32_setGclkEnable</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a48fee3ba105edc1dcee550925ac90f6d"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a48fee3ba105edc1dcee550925ac90f6d">EF_TMR32_setGclkEnable</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setGclkEnable(EF_TMR32_TYPE_PTR tmr32, uint32_t value)</div><div class="ttdoc">Sets the GCLK enable bit in the GCLK register to a certain value.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:55</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>value</code> The value of the GCLK enable bit</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md41"></a>
function &lt;tt&gt;EF_TMR32_setICR&lt;/tt&gt;</h2>
<p><em>Sets the interrupt clear register of the timer by writing to the ICR register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a8f2de51a604e7beb66db426098b7be79">EF_TMR32_setICR</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t mask</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a8f2de51a604e7beb66db426098b7be79"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a8f2de51a604e7beb66db426098b7be79">EF_TMR32_setICR</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setICR(EF_TMR32_TYPE_PTR tmr32, uint32_t mask)</div><div class="ttdoc">Sets the interrupt clear register of the timer by writing to the ICR register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:647</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>mask</code> The interrupt clear mask value to set in the ICR register. Must not exceed **EF\_TMR32\_ICR\_MAX\_VALUE**.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md42"></a>
function &lt;tt&gt;EF_TMR32_setIM&lt;/tt&gt;</h2>
<p><em>Sets the interrupt mask of the timer by writing to the IM register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a88702cef6eafdb625b8392d9aa58fa11">EF_TMR32_setIM</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t mask</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a88702cef6eafdb625b8392d9aa58fa11"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a88702cef6eafdb625b8392d9aa58fa11">EF_TMR32_setIM</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setIM(EF_TMR32_TYPE_PTR tmr32, uint32_t mask)</div><div class="ttdoc">Sets the interrupt mask of the timer by writing to the IM register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:616</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>mask</code> The interrupt mask value to set in the IM register. Must not exceed **EF\_TMR32\_IM\_MAX\_VALUE**.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md43"></a>
function &lt;tt&gt;EF_TMR32_setOneShot&lt;/tt&gt;</h2>
<p><em>Sets the timer to operate in one-shot mode by clearing the "P" bit in the CFG register to 0.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ab013c8ef6cdc697401cadb1351d42379">EF_TMR32_setOneShot</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ab013c8ef6cdc697401cadb1351d42379"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ab013c8ef6cdc697401cadb1351d42379">EF_TMR32_setOneShot</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setOneShot(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Sets the timer to operate in one-shot mode by clearing the &quot;P&quot; bit in the CFG register to 0.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:231</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md44"></a>
function &lt;tt&gt;EF_TMR32_setPR&lt;/tt&gt;</h2>
<p><em>Sets the prescaler value of the timer by writing to the PR register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a08fe49ae5e93539f493d0640328b043a">EF_TMR32_setPR</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a08fe49ae5e93539f493d0640328b043a"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a08fe49ae5e93539f493d0640328b043a">EF_TMR32_setPR</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPR(EF_TMR32_TYPE_PTR tmr32, uint32_t value)</div><div class="ttdoc">Sets the prescaler value of the timer by writing to the PR register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:566</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>value</code> The prescaler value to set in the PR register. Must not exceed **EF\_TMR32\_PR\_MAX\_VALUE**.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md45"></a>
function &lt;tt&gt;EF_TMR32_setPWM0CenterAlignedMode&lt;/tt&gt;</h2>
<p><em>Sets the PWM0 center-aligned mode.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a0a42492b716fb008dd6980193e039a17">EF_TMR32_setPWM0CenterAlignedMode</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t reload_value,</div>
<div class="line">    uint32_t cmpX_value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a0a42492b716fb008dd6980193e039a17"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a0a42492b716fb008dd6980193e039a17">EF_TMR32_setPWM0CenterAlignedMode</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0CenterAlignedMode(EF_TMR32_TYPE_PTR tmr32, uint32_t reload_value, uint32_t cmpX_value)</div><div class="ttdoc">Sets the PWM0 center-aligned mode.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:862</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>reload_value</code> The reload value to set in the PWM0CFG register. This determines the period of the PWM signal.</li>
<li><code>cmpX_value</code> The value to set in the CMPX register. This value controls the point at which the PWM signal transitions from high to low (or vice versa) in the center-aligned mode.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code.</p>
<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL.</li>
</ul>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with center-alignment on PWM0. It sets the timer to up-down counting mode and periodic mode, configures the zero and compare actions, and sets the reload and compare values as specified.</p>
<p>Internal configurations performed by the function:</p>
<ul>
<li>Sets the timer to up-down counting mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the X compare register to drive the PWM output low on up-count.</li>
<li>Configures the X compare register to drive the PWM output high on down-count.</li>
<li>Configures the Y compare register to maintain the current output state on both up and down counts.</li>
<li>Sets the reload value to define the PWM signal period.</li>
<li>Sets the X compare register value to define the transition point.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|\</div>
<div class="line">|_____/__|__\</div>
<div class="line">|   / |  |  | \</div>
<div class="line">|_/___|__|__|___\__</div>
<div class="line">      |     |</div>
<div class="line">      V     V</div>
<div class="line">  ____       ____</div>
<div class="line">      |_____|    </div>
</div><!-- fragment --><p><b>Note:</b></p>
<p>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings.</p>
<p><b>Note:</b></p>
<p>for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </p>
<h2><a class="anchor" id="autotoc_md46"></a>
function &lt;tt&gt;EF_TMR32_setPWM0EdgeAlignmentMode&lt;/tt&gt;</h2>
<p><em>Sets the PWM0 edge alignment mode.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a8d4d907e326c073a96a28e8317fc26bd">EF_TMR32_setPWM0EdgeAlignmentMode</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t reload_value,</div>
<div class="line">    uint32_t duty_cycle</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a8d4d907e326c073a96a28e8317fc26bd"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a8d4d907e326c073a96a28e8317fc26bd">EF_TMR32_setPWM0EdgeAlignmentMode</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0EdgeAlignmentMode(EF_TMR32_TYPE_PTR tmr32, uint32_t reload_value, uint32_t duty_cycle)</div><div class="ttdoc">Sets the PWM0 edge alignment mode.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:759</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>reload_value</code> The reload value to set in the PWM0CFG register. This determines the period of the PWM signal.</li>
<li><code>duty_cycle</code> The duty cycle value to set in the PWM0CFG register, representing the high time as a percentage of the period (0 to 100).</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code.</p>
<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL or<code>duty_cycle</code> &gt; 100.</li>
</ul>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with edge alignment. It sets the timer to up-count and periodic modes, configures the zero action to high, and uses the X compare register to control the output signal. The duty cycle and reload values are used to compute the compare register value.</p>
<p>Internal configurations performed by the function:</p>
<ul>
<li>Sets the timer to up-count mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the X compare register to drive the PWM output low on up-count.</li>
<li>Configures the Y compare register to maintain the current output state.</li>
<li>Calculates the X compare value based on the duty cycle and reload value.</li>
<li>Sets the reload value and compare register.</li>
<li>Ensures no change in output on the top action.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|      /|</div>
<div class="line">|_____/__|____/  |</div>
<div class="line">|   / |  |  / |  |</div>
<div class="line">|_/___|__|/___|__|____</div>
<div class="line">      |       |</div>
<div class="line">      V       V</div>
<div class="line">  ____    ____    ___   ___</div>
<div class="line">      |__|    |__|   |__|</div>
<div class="line">  duty    duty</div>
<div class="line">  cycle   cycle</div>
</div><!-- fragment --><p><b>Note:</b></p>
<p>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings.</p>
<p><b>Note:</b></p>
<p>for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </p>
<h2><a class="anchor" id="autotoc_md47"></a>
function &lt;tt&gt;EF_TMR32_setPWM0MatchingCMPXDownCountAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a9e7ceb938a22a090ae7907e013d026dd">EF_TMR32_setPWM0MatchingCMPXDownCountAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a9e7ceb938a22a090ae7907e013d026dd"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a9e7ceb938a22a090ae7907e013d026dd">EF_TMR32_setPWM0MatchingCMPXDownCountAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0MatchingCMPXDownCountAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:344</div></div>
</div><!-- fragment --><p>Configures the action of TMR0 PWM when the timer matches the CMPX value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E5_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPX value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md48"></a>
function &lt;tt&gt;EF_TMR32_setPWM0MatchingCMPXUpCountAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5329cef22cac7e6d808f69a3c5edc851">EF_TMR32_setPWM0MatchingCMPXUpCountAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a5329cef22cac7e6d808f69a3c5edc851"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a5329cef22cac7e6d808f69a3c5edc851">EF_TMR32_setPWM0MatchingCMPXUpCountAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0MatchingCMPXUpCountAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:264</div></div>
</div><!-- fragment --><p>Configures the action of TMR0 PWM when the timer matches the CMPX value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E1_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPX value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md49"></a>
function &lt;tt&gt;EF_TMR32_setPWM0MatchingCMPYDownCountAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ad800e1b9441665d57d2c11f57232778c">EF_TMR32_setPWM0MatchingCMPYDownCountAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ad800e1b9441665d57d2c11f57232778c"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ad800e1b9441665d57d2c11f57232778c">EF_TMR32_setPWM0MatchingCMPYDownCountAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0MatchingCMPYDownCountAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:324</div></div>
</div><!-- fragment --><p>Configures the action of TMR0 PWM when the timer matches the CMPY value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E4_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPY value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md50"></a>
function &lt;tt&gt;EF_TMR32_setPWM0MatchingCMPYUpCountAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a02cca84ee8407a02efa49d1ad4357cdc">EF_TMR32_setPWM0MatchingCMPYUpCountAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a02cca84ee8407a02efa49d1ad4357cdc"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a02cca84ee8407a02efa49d1ad4357cdc">EF_TMR32_setPWM0MatchingCMPYUpCountAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0MatchingCMPYUpCountAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:284</div></div>
</div><!-- fragment --><p>Configures the action of TMR0 PWM when the timer matches the CMPY value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E2_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPY value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md51"></a>
function &lt;tt&gt;EF_TMR32_setPWM0MatchingRELOADAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ab80c062a5bd682ba94d93a563c58a08b">EF_TMR32_setPWM0MatchingRELOADAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ab80c062a5bd682ba94d93a563c58a08b"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ab80c062a5bd682ba94d93a563c58a08b">EF_TMR32_setPWM0MatchingRELOADAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0MatchingRELOADAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:304</div></div>
</div><!-- fragment --><p>Configures the action of TMR0 PWM when the timer matches the RELOAD value. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the RELOAD value. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying EF_TMR32_PWM0CFG_REG_E3_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the RELOAD value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md52"></a>
function &lt;tt&gt;EF_TMR32_setPWM0MatchingZeroAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a6f73741bff7231eb72696b642dd5344e">EF_TMR32_setPWM0MatchingZeroAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a6f73741bff7231eb72696b642dd5344e"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a6f73741bff7231eb72696b642dd5344e">EF_TMR32_setPWM0MatchingZeroAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM0MatchingZeroAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:245</div></div>
</div><!-- fragment --><p>Configures the action of TMR0 PWM when the timer matches the Zero value. This function allows the user to specify what happens to the PWM output signal when the timer counter reaches zero. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM0 configuration register by modifying **EF\_TMR32\_PWM0CFG\_REG\_E0\_BIT**. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the Zero value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md53"></a>
function &lt;tt&gt;EF_TMR32_setPWM1CenterAlignedMode&lt;/tt&gt;</h2>
<p><em>Sets the PWM1 center-aligned mode.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5142ccf9f3a4ecd336c6e9364712dffd">EF_TMR32_setPWM1CenterAlignedMode</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t reload_value,</div>
<div class="line">    uint32_t cmpY_value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a5142ccf9f3a4ecd336c6e9364712dffd"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a5142ccf9f3a4ecd336c6e9364712dffd">EF_TMR32_setPWM1CenterAlignedMode</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1CenterAlignedMode(EF_TMR32_TYPE_PTR tmr32, uint32_t reload_value, uint32_t cmpY_value)</div><div class="ttdoc">Sets the PWM1 center-aligned mode.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:911</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>reload_value</code> The reload value to set in the PWM1CFG register. This determines the period of the PWM signal.</li>
<li><code>cmpY_value</code> The value to set in the CMPX register. This value controls the point at which the PWM signal transitions from high to low (or vice versa) in the center-aligned mode.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code.</p>
<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL.</li>
</ul>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with center-alignment on PWM1. It sets the timer to up-down counting mode and periodic mode, configures the zero and compare actions, and sets the reload and compare values as specified.</p>
<p>Internal configurations performed by the function:</p>
<ul>
<li>Sets the timer to up-down counting mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the Y compare register to drive the PWM output low on up-count.</li>
<li>Configures the Y compare register to drive the PWM output high on down-count.</li>
<li>Configures the X compare register to maintain the current output state on both up and down counts.</li>
<li>Sets the reload value to define the PWM signal period.</li>
<li>Sets the X compare register value to define the transition point.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|\</div>
<div class="line">|_____/__|__\</div>
<div class="line">|   / |  |  | \</div>
<div class="line">|_/___|__|__|___\__</div>
<div class="line">      |     |</div>
<div class="line">      V     V</div>
<div class="line">  ____       ____ </div>
<div class="line">      |_____|    </div>
</div><!-- fragment --><p><b>Note:</b></p>
<p>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings.</p>
<p><b>Note:</b></p>
<p>for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </p>
<h2><a class="anchor" id="autotoc_md54"></a>
function &lt;tt&gt;EF_TMR32_setPWM1EdgeAlignmentMode&lt;/tt&gt;</h2>
<p><em>Sets the PWM1 edge alignment mode.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a56341d8e521f6b5001cddf60b93fe6f1">EF_TMR32_setPWM1EdgeAlignmentMode</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t reload_value,</div>
<div class="line">    uint32_t duty_cycle</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a56341d8e521f6b5001cddf60b93fe6f1"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a56341d8e521f6b5001cddf60b93fe6f1">EF_TMR32_setPWM1EdgeAlignmentMode</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1EdgeAlignmentMode(EF_TMR32_TYPE_PTR tmr32, uint32_t reload_value, uint32_t duty_cycle)</div><div class="ttdoc">Sets the PWM1 edge alignment mode.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:810</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>reload_value</code> The reload value to set in the PWM1CFG register. This determines the period of the PWM signal.</li>
<li><code>duty_cycle</code> The duty cycle value to set in the PWM1CFG register, representing the high time as a percentage of the period (0 to 100).</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code.</p>
<ul>
<li>EF_DRIVER_OK: Configuration was successful.</li>
<li>EF_DRIVER_ERROR_PARAMETER: Invalid input parameters, such as <code>tmr32</code> being NULL or<code>duty_cycle</code> &gt; 100.</li>
</ul>
<p>This function configures the specified 32-bit timer (<code>tmr32</code>) to generate a PWM signal with edge alignment on PWM1. It sets the timer to up-count and periodic modes, configures the zero action to high, and uses the Y compare register to control the output signal. The duty cycle and reload values are used to compute the compare register value.</p>
<p>Internal configurations performed by the function:</p>
<ul>
<li>Sets the timer to up-count mode.</li>
<li>Configures the timer for periodic operation.</li>
<li>Sets the zero action to drive the PWM output high.</li>
<li>Configures the Y compare register to drive the PWM output low on up-count.</li>
<li>Configures the X compare register to maintain the current output state.</li>
<li>Calculates the Y compare value based on the duty cycle and reload value.</li>
<li>Sets the reload value and compare register.</li>
<li>Ensures no change in output on the top action.</li>
</ul>
<p>Example PWM waveform: </p><div class="fragment"><div class="line">|       /|      /|</div>
<div class="line">|_____/__|____/  |</div>
<div class="line">|   / |  |  / |  |</div>
<div class="line">|_/___|__|/___|__|____</div>
<div class="line">      |       |</div>
<div class="line">      V       V</div>
<div class="line">  ____    ____    ___   ___</div>
<div class="line">      |__|    |__|   |__|</div>
<div class="line">  duty    duty</div>
<div class="line">  cycle   cycle</div>
</div><!-- fragment --><p><b>Note:</b></p>
<p>Ensure the timer instance (<code>tmr32</code>) is correctly initialized before calling this function. The reload value and compare value must align with the timer's capabilities and clock settings.</p>
<p><b>Note:</b></p>
<p>for more information, check <a href="https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/">https://www.linkedin.com/pulse/center-aligned-pwm-vs-edge-aligned-neobionics-tn/</a> </p>
<h2><a class="anchor" id="autotoc_md55"></a>
function &lt;tt&gt;EF_TMR32_setPWM1MatchingCMPXDownCountAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ad579dc1e3910c7b4a78cde1e6e14bf8d">EF_TMR32_setPWM1MatchingCMPXDownCountAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ad579dc1e3910c7b4a78cde1e6e14bf8d"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ad579dc1e3910c7b4a78cde1e6e14bf8d">EF_TMR32_setPWM1MatchingCMPXDownCountAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1MatchingCMPXDownCountAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:465</div></div>
</div><!-- fragment --><p>Configures the action of TMR1 PWM when the timer matches the CMPX value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E5_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPX value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md56"></a>
function &lt;tt&gt;EF_TMR32_setPWM1MatchingCMPXUpCountingAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a0e27b3011128b05f745f22f7f8381464">EF_TMR32_setPWM1MatchingCMPXUpCountingAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a0e27b3011128b05f745f22f7f8381464"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a0e27b3011128b05f745f22f7f8381464">EF_TMR32_setPWM1MatchingCMPXUpCountingAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1MatchingCMPXUpCountingAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:384</div></div>
</div><!-- fragment --><p>Configures the action of TMR1 PWM when the timer matches the CMPX value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPX value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E1_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPX value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md57"></a>
function &lt;tt&gt;EF_TMR32_setPWM1MatchingCMPYDownCountAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a3dd40d43dac4fee39dbe7717ee848ecd">EF_TMR32_setPWM1MatchingCMPYDownCountAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a3dd40d43dac4fee39dbe7717ee848ecd"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a3dd40d43dac4fee39dbe7717ee848ecd">EF_TMR32_setPWM1MatchingCMPYDownCountAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1MatchingCMPYDownCountAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:445</div></div>
</div><!-- fragment --><p>Configures the action of TMR1 PWM when the timer matches the CMPY value while down counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting down. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E4_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPY value while counting down. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md58"></a>
function &lt;tt&gt;EF_TMR32_setPWM1MatchingCMPYUpCountingAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#afc9656b5c30e601673caa747caeb51c1">EF_TMR32_setPWM1MatchingCMPYUpCountingAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_afc9656b5c30e601673caa747caeb51c1"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#afc9656b5c30e601673caa747caeb51c1">EF_TMR32_setPWM1MatchingCMPYUpCountingAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1MatchingCMPYUpCountingAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:405</div></div>
</div><!-- fragment --><p>Configures the action of TMR1 PWM when the timer matches the CMPY value while up counting. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the CMPY value while counting up. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E2_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the CMPY value while counting up. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md59"></a>
function &lt;tt&gt;EF_TMR32_setPWM1MatchingRELOADAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a401ddd8eb0f58c2e154b0e4bed3bc4a2">EF_TMR32_setPWM1MatchingRELOADAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a401ddd8eb0f58c2e154b0e4bed3bc4a2"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a401ddd8eb0f58c2e154b0e4bed3bc4a2">EF_TMR32_setPWM1MatchingRELOADAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1MatchingRELOADAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:425</div></div>
</div><!-- fragment --><p>Configures the action of TMR1 PWM when the timer matches the RELOAD value. This function allows the user to specify what happens to the PWM output signal when the timer counter matches the RELOAD value. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying EF_TMR32_PWM1CFG_REG_E3_BI. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the RELOAD value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md60"></a>
function &lt;tt&gt;EF_TMR32_setPWM1MatchingZeroAction&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a2e80ed5c92214b2858766e0d8b233008">EF_TMR32_setPWM1MatchingZeroAction</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t action</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a2e80ed5c92214b2858766e0d8b233008"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a2e80ed5c92214b2858766e0d8b233008">EF_TMR32_setPWM1MatchingZeroAction</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWM1MatchingZeroAction(EF_TMR32_TYPE_PTR tmr32, uint32_t action)</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:364</div></div>
</div><!-- fragment --><p>Configures the action of TMR1 PWM when the timer matches the Zero value. This function allows the user to specify what happens to the PWM output signal when the timer counter reaches zero. The available actions are: no action, set the output to LOW, set the output to HIGH, or invert the current state of the output. The action is configured in the PWM1 configuration register by modifying **EF\_TMR32\_PWM1CFG\_REG\_E0\_BIT**. This is commonly used in PWM applications to define the output response when the counter reaches a particular value.</p>
<p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>action</code> A uint32_t value specifying the action to take when the timer matches the Zero value. The possible values are:<ul>
<li>EF_TMR32_ACTION_NONE: No action (do nothing)</li>
<li>EF_TMR32_ACTION_LOW: Set the PWM output to LOW</li>
<li>EF_TMR32_ACTION_HIGH: Set the PWM output to HIGH</li>
<li>EF_TMR32_ACTION_INVERT: Invert the current output state</li>
</ul>
</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md61"></a>
function &lt;tt&gt;EF_TMR32_setPWMDeadtime&lt;/tt&gt;</h2>
<p><em>Sets the PWM dead time value of the PWM by writing to the PWMDT register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a09b86f3fe84a2823f619704f49df51ff">EF_TMR32_setPWMDeadtime</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a09b86f3fe84a2823f619704f49df51ff"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a09b86f3fe84a2823f619704f49df51ff">EF_TMR32_setPWMDeadtime</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPWMDeadtime(EF_TMR32_TYPE_PTR tmr32, uint32_t value)</div><div class="ttdoc">Sets the PWM dead time value of the PWM by writing to the PWMDT register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:549</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>value</code> The dead time value to set in the PWMDT register. Must not exceed **EF\_TMR32\_PWMDT\_MAX\_VALUE**.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md62"></a>
function &lt;tt&gt;EF_TMR32_setPeriodic&lt;/tt&gt;</h2>
<p><em>Sets the timer to operate in periodic mode by setting the "P" bit in the CFG register to 1.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ae1b99e7a248aa01794677de568a89c12">EF_TMR32_setPeriodic</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_ae1b99e7a248aa01794677de568a89c12"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#ae1b99e7a248aa01794677de568a89c12">EF_TMR32_setPeriodic</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setPeriodic(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Sets the timer to operate in periodic mode by setting the &quot;P&quot; bit in the CFG register to 1.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:218</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md63"></a>
function &lt;tt&gt;EF_TMR32_setRELOAD&lt;/tt&gt;</h2>
<p><em>Sets the reload value of a 32-bit timer by writing to the RELOAD register.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5dd014cbe453c7e9ad161bb95c1a5478">EF_TMR32_setRELOAD</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32,</div>
<div class="line">    uint32_t value</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a5dd014cbe453c7e9ad161bb95c1a5478"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a5dd014cbe453c7e9ad161bb95c1a5478">EF_TMR32_setRELOAD</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setRELOAD(EF_TMR32_TYPE_PTR tmr32, uint32_t value)</div><div class="ttdoc">Sets the reload value of a 32-bit timer by writing to the RELOAD register.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:485</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR**, which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
<li><code>value</code> The reload value to set in the RELOAD register.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type EF_DRIVER_STATUS: returns a success or error code. </p>
<h2><a class="anchor" id="autotoc_md64"></a>
function &lt;tt&gt;EF_TMR32_setUpCount&lt;/tt&gt;</h2>
<p><em>Sets the timer direction to be up counting by setting the "DIR" field in the CTRL register to 0b10.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#aadb3f68daef94e6e3668a88eea378fd2">EF_TMR32_setUpCount</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_aadb3f68daef94e6e3668a88eea378fd2"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#aadb3f68daef94e6e3668a88eea378fd2">EF_TMR32_setUpCount</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setUpCount(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Sets the timer direction to be up counting by setting the &quot;DIR&quot; field in the CTRL register to 0b10.</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:176</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code </p>
<h2><a class="anchor" id="autotoc_md65"></a>
function &lt;tt&gt;EF_TMR32_setUpDownCount&lt;/tt&gt;</h2>
<p><em>Sets the timer direction to be up/down counting by setting the "DIR" field in the CTRL register to 0b11.</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a2fd6766483cd71135ff6ba22f0af2e81">EF_TMR32_setUpDownCount</a> (</div>
<div class="line">    <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE_PTR</a> tmr32</div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32_8c_html_a2fd6766483cd71135ff6ba22f0af2e81"><div class="ttname"><a href="_e_f___t_m_r32_8c.html#a2fd6766483cd71135ff6ba22f0af2e81">EF_TMR32_setUpDownCount</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_setUpDownCount(EF_TMR32_TYPE_PTR tmr32)</div><div class="ttdoc">Sets the timer direction to be up/down counting by setting the &quot;DIR&quot; field in the CTRL register to 0b...</div><div class="ttdef"><b>Definition:</b> EF_TMR32.c:204</div></div>
</div><!-- fragment --><p><b>Parameters:</b></p>
<ul>
<li><code>tmr32</code> An **EF\_TMR32\_TYPE\_PTR** , which points to the base memory address of TMR32 registers.**EF\_TMR32\_TYPE** is a structure that contains the TMR32 registers.</li>
</ul>
<p><b>Returns:</b></p>
<p>status A value of type **EF\_DRIVER\_STATUS** : returns a success or error code</p>
<h1><a class="anchor" id="autotoc_md66"></a>
Macros Documentation</h1>
<h2><a class="anchor" id="autotoc_md67"></a>
define &lt;tt&gt;EF_TMR32_ACTION_HIGH&lt;/tt&gt;</h2>
<p><em>Set output to HIGH when match occurs.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_ACTION_HIGH ((uint32_t)2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
define &lt;tt&gt;EF_TMR32_ACTION_INVERT&lt;/tt&gt;</h2>
<p><em>Invert the output when match occurs.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_ACTION_INVERT ((uint32_t)3)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md69"></a>
define &lt;tt&gt;EF_TMR32_ACTION_LOW&lt;/tt&gt;</h2>
<p><em>Set output to LOW when match occurs.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_ACTION_LOW ((uint32_t)1)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md70"></a>
define &lt;tt&gt;EF_TMR32_ACTION_MAX_VALUE&lt;/tt&gt;</h2>
<p><em>Maximum value for the action field.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_ACTION_MAX_VALUE ((uint32_t)3)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md71"></a>
define &lt;tt&gt;EF_TMR32_ACTION_NONE&lt;/tt&gt;</h2>
<p><em>No action on match (do nothing)</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_ACTION_NONE ((uint32_t)0)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md72"></a>
define &lt;tt&gt;EF_TMR32_ICR_MAX_VALUE&lt;/tt&gt;</h2>
<p><em>Maximum value for the ICR register.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_ICR_MAX_VALUE ((uint32_t)2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md73"></a>
define &lt;tt&gt;EF_TMR32_IM_MAX_VALUE&lt;/tt&gt;</h2>
<p><em>Maximum value for the IM register.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_IM_MAX_VALUE ((uint32_t)2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md74"></a>
define &lt;tt&gt;EF_TMR32_PR_MAX_VALUE&lt;/tt&gt;</h2>
<p><em>Maximum value for the PR register.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PR_MAX_VALUE ((uint32_t)0x0000FFFF)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md75"></a>
define &lt;tt&gt;EF_TMR32_PWMDT_MAX_VALUE&lt;/tt&gt;</h2>
<p><em>Maximum value for the deadtime register.</em> </p><div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWMDT_MAX_VALUE ((uint32_t)0x000000FF)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md76"></a>
File EF_TMR32_example.h</h1>
<p><em>C header file containing an example of how to use the TMR32 APIs.</em></p>
<h1><a class="anchor" id="autotoc_md77"></a>
Functions</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadLeft">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM\_Example** (void) <br  />
<em>Example of PWM Usage Example usage:</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">**EF\_DRIVER\_STATUS**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_normalExample** (void) <br  />
<em>Example of Normal Usage Example usage:</em>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md78"></a>
Functions Documentation</h1>
<h2><a class="anchor" id="autotoc_md79"></a>
function &lt;tt&gt;EF_TMR32_PWM_Example&lt;/tt&gt;</h2>
<p><em>Example of PWM Usage Example usage:</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32__example_8c.html#ad8da2bd7958c523a00a2f04b58539b0d">EF_TMR32_PWM_Example</a> (</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32__example_8c_html_ad8da2bd7958c523a00a2f04b58539b0d"><div class="ttname"><a href="_e_f___t_m_r32__example_8c.html#ad8da2bd7958c523a00a2f04b58539b0d">EF_TMR32_PWM_Example</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_PWM_Example(void)</div><div class="ttdoc">Example of PWM Usage Example usage:</div><div class="ttdef"><b>Definition:</b> EF_TMR32_example.c:118</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">    #include &quot;<a class="code" href="_e_f___t_m_r32_8h.html">EF_TMR32.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">    #define Example_TMR32_BASE_ADDRESS 0x40000000</span></div>
<div class="line"><span class="preprocessor">    #define TMR320 ((EF_TMR32_TYPE_PTR)Example_TMR32_BASE_ADDRESS)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32__example_8c.html#ad8da2bd7958c523a00a2f04b58539b0d">EF_TMR32_PWM_Example</a>(<span class="keywordtype">void</span>) {</div>
<div class="line">    <a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> status;</div>
<div class="line"> </div>
<div class="line">    uint32_t reload_value = 10000; <span class="comment">// Timer reload value</span></div>
<div class="line">    uint32_t duty_cycle = 70;       <span class="comment">// Duty cycle for PWM0</span></div>
<div class="line">    uint32_t cmpY_value = 500;      <span class="comment">// Compare value for PWM1</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 1: Enable GCLK</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a48fee3ba105edc1dcee550925ac90f6d">EF_TMR32_setGclkEnable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, 1);</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code hl_define" href="_e_f___driver___common_8h.html#ab56c746d5d1672835c101f00f7c90b7c">EF_DRIVER_OK</a>) {<span class="keywordflow">return</span> status;}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2: Enable the timer</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a03bb5b7b456bda2803eb6e0bc907d2b4">EF_TMR32_enable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3: Enable PWM0</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a34eb34d261146ff2dbb5b1765309fb10">EF_TMR32_PWM0Enable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code hl_define" href="_e_f___driver___common_8h.html#ab56c746d5d1672835c101f00f7c90b7c">EF_DRIVER_OK</a>) {<span class="keywordflow">return</span> status;}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 4: Set PWM0 to Edge-Aligned Mode</span></div>
<div class="line">    <span class="comment">// Set PWM0 to edge-aligned mode with 70% duty cycle</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a8d4d907e326c073a96a28e8317fc26bd">EF_TMR32_setPWM0EdgeAlignmentMode</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, reload_value, duty_cycle);</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code hl_define" href="_e_f___driver___common_8h.html#ab56c746d5d1672835c101f00f7c90b7c">EF_DRIVER_OK</a>) {<span class="keywordflow">return</span> status;}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 5: Enable PWM1</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#acbae8bfd22ccc3ada22d403e22274850">EF_TMR32_PWM1Enable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 6: Set PWM1 to Center-Aligned Mode</span></div>
<div class="line">    <span class="comment">// Set PWM1 to center-aligned mode with a specific CMPY value</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5142ccf9f3a4ecd336c6e9364712dffd">EF_TMR32_setPWM1CenterAlignedMode</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, reload_value, cmpY_value);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 7: Disable the timer</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a55e09ad517a12af2d293982a1e0f2d0d">EF_TMR32_disable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="_e_f___driver___common_8h.html#ab56c746d5d1672835c101f00f7c90b7c">EF_DRIVER_OK</a>;</div>
<div class="line">}</div>
<div class="ttc" id="a_e_f___driver___common_8h_html_ab56c746d5d1672835c101f00f7c90b7c"><div class="ttname"><a href="_e_f___driver___common_8h.html#ab56c746d5d1672835c101f00f7c90b7c">EF_DRIVER_OK</a></div><div class="ttdeci">#define EF_DRIVER_OK</div><div class="ttdoc">Operation succeeded.</div><div class="ttdef"><b>Definition:</b> EF_Driver_Common.h:40</div></div>
<div class="ttc" id="a_e_f___t_m_r32_8h_html"><div class="ttname"><a href="_e_f___t_m_r32_8h.html">EF_TMR32.h</a></div><div class="ttdoc">C header file for TMR32 APIs which contains the function prototypes.</div></div>
<div class="ttc" id="a_e_f___t_m_r32__example_8c_html_a67e71266638e5924747ef448c00656b3"><div class="ttname"><a href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a></div><div class="ttdeci">#define TMR320</div><div class="ttdef"><b>Definition:</b> EF_TMR32_example.c:38</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md80"></a>
function &lt;tt&gt;EF_TMR32_normalExample&lt;/tt&gt;</h2>
<p><em>Example of Normal Usage Example usage:</em> </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32__example_8c.html#a1eb6a05af29b879f3bbc2b6acdde3d7b">EF_TMR32_normalExample</a> (</div>
<div class="line">    <span class="keywordtype">void</span></div>
<div class="line">) </div>
<div class="ttc" id="a_e_f___t_m_r32__example_8c_html_a1eb6a05af29b879f3bbc2b6acdde3d7b"><div class="ttname"><a href="_e_f___t_m_r32__example_8c.html#a1eb6a05af29b879f3bbc2b6acdde3d7b">EF_TMR32_normalExample</a></div><div class="ttdeci">EF_DRIVER_STATUS EF_TMR32_normalExample(void)</div><div class="ttdoc">Example of Normal Usage Example usage:</div><div class="ttdef"><b>Definition:</b> EF_TMR32_example.c:60</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_e_f___t_m_r32_8h.html">EF_TMR32.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define Example_TMR32_BASE_ADDRESS 0x40000000</span></div>
<div class="line"><span class="preprocessor">#define TMR320 ((EF_TMR32_TYPE_PTR)Example_TMR32_BASE_ADDRESS)</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> <a class="code hl_function" href="_e_f___t_m_r32__example_8c.html#a1eb6a05af29b879f3bbc2b6acdde3d7b">EF_TMR32_normalExample</a>(<span class="keywordtype">void</span>){</div>
<div class="line">    <span class="comment">// Now let&#39;s configure the timer to operate in one-shot mode</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_e_f___driver___common_8h.html#ad1c99136d1edfd0a7757f5b81600a351">EF_DRIVER_STATUS</a> status;</div>
<div class="line"> </div>
<div class="line">    uint32_t reload_value = 10000; <span class="comment">// Timer reload value</span></div>
<div class="line">    uint32_t cmpY_value = 500;      <span class="comment">// Compare value for PWM1</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 1: Enable GCLK</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a48fee3ba105edc1dcee550925ac90f6d">EF_TMR32_setGclkEnable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, 1);</div>
<div class="line">    <span class="keywordflow">if</span> (status != <a class="code hl_define" href="_e_f___driver___common_8h.html#ab56c746d5d1672835c101f00f7c90b7c">EF_DRIVER_OK</a>) {<span class="keywordflow">return</span> status;}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 2: Enable the timer</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a03bb5b7b456bda2803eb6e0bc907d2b4">EF_TMR32_enable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 3: Set mode to up-count</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#aadb3f68daef94e6e3668a88eea378fd2">EF_TMR32_setUpCount</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 4: Set mode to periodic</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ae1b99e7a248aa01794677de568a89c12">EF_TMR32_setPeriodic</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 5: Set the reload value</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5dd014cbe453c7e9ad161bb95c1a5478">EF_TMR32_setRELOAD</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, reload_value);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 6: Set the compare value</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a025b4b548381e4d01e729cb69b5dff3b">EF_TMR32_setCMPY</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, cmpY_value);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 7: Set the timer to one-shot mode  </span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#ab013c8ef6cdc697401cadb1351d42379">EF_TMR32_setOneShot</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 8: Restart the timer</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5eefc74b17c0183939742ab664fe84db">EF_TMR32_restart</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 9: wait for the timer to finish counting</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100000; i++) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 10: Check the time flag to ensure the timer has finished counting</span></div>
<div class="line">    uint32_t flag;</div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a7d0794cbbf8270e4301fa1b3de960f6e">EF_TMR32_isCMPYMatch</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, &amp;flag);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (flag == 1) {</div>
<div class="line">        <span class="comment">// clear the flag</span></div>
<div class="line">        status = EF_TMR32_clearCMPYMatch(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 11: Restart the timer</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a5eefc74b17c0183939742ab664fe84db">EF_TMR32_restart</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 12: Read the timer value</span></div>
<div class="line">    uint32_t tmr_value;</div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a6c0942ecf91efd6f92a22f9881f9b67f">EF_TMR32_getTMR</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>, &amp;tmr_value);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 13: Disable the timer</span></div>
<div class="line">    status = <a class="code hl_function" href="_e_f___t_m_r32_8c.html#a55e09ad517a12af2d293982a1e0f2d0d">EF_TMR32_disable</a>(<a class="code hl_define" href="_e_f___t_m_r32__example_8c.html#a67e71266638e5924747ef448c00656b3">TMR320</a>);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md81"></a>
File EF_TMR32_regs.h</h1>
<h1><a class="anchor" id="autotoc_md82"></a>
Structures and Types</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadLeft">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">typedef struct **\_EF\_TMR32\_TYPE\_**   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_TYPE** <br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">typedef **EF\_TMR32\_TYPE** *   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_TYPE\_PTR** <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">struct   </td><td class="markdownTableBodyLeft">**\_EF\_TMR32\_TYPE\_** <br  />
   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md83"></a>
Macros</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Type   </th><th class="markdownTableHeadLeft">Name    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CFG\_REG\_DIR\_BIT** (uint32_t)(0)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CFG\_REG\_DIR\_MASK** (uint32_t)(0x3)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CFG\_REG\_P\_BIT** (uint32_t)(2)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CFG\_REG\_P\_MASK** (uint32_t)(0x4)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_DTE\_BIT** (uint32_t)(4)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_DTE\_MASK** (uint32_t)(0x10)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_P0E\_BIT** (uint32_t)(2)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_P0E\_MASK** (uint32_t)(0x4)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_P1E\_BIT** (uint32_t)(3)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_P1E\_MASK** (uint32_t)(0x8)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_PI0\_BIT** (uint32_t)(5)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_PI0\_MASK** (uint32_t)(0x20)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_PI1\_BIT** (uint32_t)(6)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_PI1\_MASK** (uint32_t)(0x40)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_TE\_BIT** (uint32_t)(0)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_TE\_MASK** (uint32_t)(0x1)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_TS\_BIT** (uint32_t)(1)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_CTRL\_REG\_TS\_MASK** (uint32_t)(0x2)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_MX\_FLAG** ((uint32_t)0x2)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_MY\_FLAG** ((uint32_t)0x4)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E0\_BIT** (uint32_t)(0)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E0\_MASK** (uint32_t)(0x3)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E1\_BIT** (uint32_t)(2)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E1\_MASK** (uint32_t)(0xc)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E2\_BIT** (uint32_t)(4)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E2\_MASK** (uint32_t)(0x30)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E3\_BIT** (uint32_t)(6)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E3\_MASK** (uint32_t)(0xc0)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E4\_BIT** (uint32_t)(8)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E4\_MASK** (uint32_t)(0x300)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E5\_BIT** (uint32_t)(10)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM0CFG\_REG\_E5\_MASK** (uint32_t)(0xc00)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E0\_BIT** (uint32_t)(0)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E0\_MASK** (uint32_t)(0x3)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E1\_BIT** (uint32_t)(2)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E1\_MASK** (uint32_t)(0xc)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E2\_BIT** (uint32_t)(4)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E2\_MASK** (uint32_t)(0x30)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E3\_BIT** (uint32_t)(6)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E3\_MASK** (uint32_t)(0xc0)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E4\_BIT** (uint32_t)(8)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E4\_MASK** (uint32_t)(0x300)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E5\_BIT** (uint32_t)(10)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_PWM1CFG\_REG\_E5\_MASK** (uint32_t)(0xc00)<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**EF\_TMR32\_TO\_FLAG** ((uint32_t)0x1)<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**IO\_TYPES** <br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**\_\_R** volatile const uint32_t<br  />
    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**\_\_RW** volatile uint32_t<br  />
    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">define   </td><td class="markdownTableBodyLeft">**\_\_W** volatile uint32_t<br  />
   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md84"></a>
Structures and Types Documentation</h1>
<h2><a class="anchor" id="autotoc_md85"></a>
typedef &lt;tt&gt;EF_TMR32_TYPE&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">_EF_TMR32_TYPE_</a> <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE</a>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md86"></a>
typedef &lt;tt&gt;EF_TMR32_TYPE_PTR&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_struct" href="struct___e_f___t_m_r32___t_y_p_e__.html">EF_TMR32_TYPE</a>* <a class="code hl_typedef" href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a>;</div>
<div class="ttc" id="a_e_f___t_m_r32__regs_8h_html_a42a4bf3583e288f8eb18ce061bfdf60b"><div class="ttname"><a href="_e_f___t_m_r32__regs_8h.html#a42a4bf3583e288f8eb18ce061bfdf60b">EF_TMR32_TYPE_PTR</a></div><div class="ttdeci">EF_TMR32_TYPE * EF_TMR32_TYPE_PTR</div><div class="ttdef"><b>Definition:</b> EF_TMR32_regs.h:113</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md87"></a>
struct &lt;tt&gt;_EF_TMR32_TYPE_&lt;/tt&gt;</h2>
<p>Variables:</p>
<ul>
<li>**\_\_W** CFG <br  />
</li>
<li>**\_\_W** CMPX <br  />
</li>
<li>**\_\_W** CMPY <br  />
</li>
<li>**\_\_W** CTRL <br  />
</li>
<li>**\_\_W** GCLK <br  />
</li>
<li>**\_\_W** IC <br  />
</li>
<li>**\_\_RW** IM <br  />
</li>
<li>**\_\_R** MIS <br  />
</li>
<li>**\_\_W** PR <br  />
</li>
<li>**\_\_W** PWM0CFG <br  />
</li>
<li>**\_\_W** PWM1CFG <br  />
</li>
<li>**\_\_W** PWMDT <br  />
</li>
<li>**\_\_W** PWMFC <br  />
</li>
<li>**\_\_W** RELOAD <br  />
</li>
<li>**\_\_R** RIS <br  />
</li>
<li>**\_\_R** TMR <br  />
</li>
<li>**\_\_R** reserved_0 <br  />
</li>
</ul>
<h1><a class="anchor" id="autotoc_md88"></a>
Macros Documentation</h1>
<h2><a class="anchor" id="autotoc_md89"></a>
define &lt;tt&gt;EF_TMR32_CFG_REG_DIR_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CFG_REG_DIR_BIT (uint32_t)(0)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md90"></a>
define &lt;tt&gt;EF_TMR32_CFG_REG_DIR_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CFG_REG_DIR_MASK (uint32_t)(0x3)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md91"></a>
define &lt;tt&gt;EF_TMR32_CFG_REG_P_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CFG_REG_P_BIT (uint32_t)(2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md92"></a>
define &lt;tt&gt;EF_TMR32_CFG_REG_P_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CFG_REG_P_MASK (uint32_t)(0x4)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md93"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_DTE_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_DTE_BIT (uint32_t)(4)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md94"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_DTE_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_DTE_MASK (uint32_t)(0x10)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md95"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_P0E_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_P0E_BIT (uint32_t)(2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md96"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_P0E_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_P0E_MASK (uint32_t)(0x4)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md97"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_P1E_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_P1E_BIT (uint32_t)(3)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md98"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_P1E_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_P1E_MASK (uint32_t)(0x8)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md99"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_PI0_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_PI0_BIT (uint32_t)(5)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md100"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_PI0_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_PI0_MASK (uint32_t)(0x20)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md101"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_PI1_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_PI1_BIT (uint32_t)(6)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md102"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_PI1_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_PI1_MASK (uint32_t)(0x40)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_TE_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_TE_BIT (uint32_t)(0)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md104"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_TE_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_TE_MASK (uint32_t)(0x1)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md105"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_TS_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_TS_BIT (uint32_t)(1)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md106"></a>
define &lt;tt&gt;EF_TMR32_CTRL_REG_TS_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_CTRL_REG_TS_MASK (uint32_t)(0x2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md107"></a>
define &lt;tt&gt;EF_TMR32_MX_FLAG&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_MX_FLAG ((uint32_t)0x2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md108"></a>
define &lt;tt&gt;EF_TMR32_MY_FLAG&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_MY_FLAG ((uint32_t)0x4)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md109"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E0_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E0_BIT (uint32_t)(0)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md110"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E0_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E0_MASK (uint32_t)(0x3)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md111"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E1_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E1_BIT (uint32_t)(2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md112"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E1_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E1_MASK (uint32_t)(0xc)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md113"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E2_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E2_BIT (uint32_t)(4)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md114"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E2_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E2_MASK (uint32_t)(0x30)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md115"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E3_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E3_BIT (uint32_t)(6)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md116"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E3_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E3_MASK (uint32_t)(0xc0)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md117"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E4_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E4_BIT (uint32_t)(8)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md118"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E4_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E4_MASK (uint32_t)(0x300)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md119"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E5_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E5_BIT (uint32_t)(10)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md120"></a>
define &lt;tt&gt;EF_TMR32_PWM0CFG_REG_E5_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM0CFG_REG_E5_MASK (uint32_t)(0xc00)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md121"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E0_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E0_BIT (uint32_t)(0)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md122"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E0_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E0_MASK (uint32_t)(0x3)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md123"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E1_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E1_BIT (uint32_t)(2)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md124"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E1_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E1_MASK (uint32_t)(0xc)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md125"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E2_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E2_BIT (uint32_t)(4)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md126"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E2_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E2_MASK (uint32_t)(0x30)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md127"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E3_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E3_BIT (uint32_t)(6)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md128"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E3_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E3_MASK (uint32_t)(0xc0)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md129"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E4_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E4_BIT (uint32_t)(8)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md130"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E4_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E4_MASK (uint32_t)(0x300)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md131"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E5_BIT&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E5_BIT (uint32_t)(10)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md132"></a>
define &lt;tt&gt;EF_TMR32_PWM1CFG_REG_E5_MASK&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_PWM1CFG_REG_E5_MASK (uint32_t)(0xc00)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md133"></a>
define &lt;tt&gt;EF_TMR32_TO_FLAG&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define EF_TMR32_TO_FLAG ((uint32_t)0x1)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md134"></a>
define &lt;tt&gt;IO_TYPES&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define IO_TYPES </span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md135"></a>
define &lt;tt&gt;__R&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define __R volatile const uint32_t</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md136"></a>
define &lt;tt&gt;__RW&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define __RW volatile       uint32_t</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md137"></a>
define &lt;tt&gt;__W&lt;/tt&gt;</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#define __W volatile       uint32_t</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
